<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>LUMA: ObjectManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="lumalogo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LUMA
   &#160;<span id="projectnumber">1.2.0-alpha</span>
   </div>
   <div id="projectbrief">2D/3D FSI lattice Boltzmann solver for CPU</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_object_manager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ObjectManager Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Object Manager class.  
 <a href="class_object_manager.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_object_manager_8h_source.html">ObjectManager.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2ec2df889c396d94d2fe1807c10847bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_manager.html#a2ec2df889c396d94d2fe1807c10847bb">ibm_apply</a> ()</td></tr>
<tr class="memdesc:a2ec2df889c396d94d2fe1807c10847bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform IBM procedure.  <a href="#a2ec2df889c396d94d2fe1807c10847bb">More...</a><br /></td></tr>
<tr class="separator:a2ec2df889c396d94d2fe1807c10847bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89336910b6f3157e5b17b4ea6d30a12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_manager.html#af89336910b6f3157e5b17b4ea6d30a12">ibm_build_body</a> (int body_type)</td></tr>
<tr class="memdesc:af89336910b6f3157e5b17b4ea6d30a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a prefab immersed boundary body.  <a href="#af89336910b6f3157e5b17b4ea6d30a12">More...</a><br /></td></tr>
<tr class="separator:af89336910b6f3157e5b17b4ea6d30a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8270fe5b646e512a34748b5ca51671c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_manager.html#ac8270fe5b646e512a34748b5ca51671c">ibm_build_body</a> (<a class="el" href="class_p_cpts.html">PCpts</a> *_PCpts, <a class="el" href="class_grid_obj.html">GridObj</a> *owner)</td></tr>
<tr class="memdesc:ac8270fe5b646e512a34748b5ca51671c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for building a body from a point cloud.  <a href="#ac8270fe5b646e512a34748b5ca51671c">More...</a><br /></td></tr>
<tr class="separator:ac8270fe5b646e512a34748b5ca51671c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e5e286a6fe1d9fcaf393ffed329250"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_manager.html#aa4e5e286a6fe1d9fcaf393ffed329250">ibm_initialise</a> ()</td></tr>
<tr class="memdesc:aa4e5e286a6fe1d9fcaf393ffed329250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise the array of iBodies.  <a href="#aa4e5e286a6fe1d9fcaf393ffed329250">More...</a><br /></td></tr>
<tr class="separator:aa4e5e286a6fe1d9fcaf393ffed329250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e55e3a84bae37a75f8487fd575169fb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_manager.html#a4e55e3a84bae37a75f8487fd575169fb">ibm_deltakernel</a> (double rad, double dilation)</td></tr>
<tr class="memdesc:a4e55e3a84bae37a75f8487fd575169fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to evaluate delta kernel at supplied location.  <a href="#a4e55e3a84bae37a75f8487fd575169fb">More...</a><br /></td></tr>
<tr class="separator:a4e55e3a84bae37a75f8487fd575169fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff31915ad0effdcc8dc18f602ddd1c20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_manager.html#aff31915ad0effdcc8dc18f602ddd1c20">ibm_interpol</a> (int ib)</td></tr>
<tr class="memdesc:aff31915ad0effdcc8dc18f602ddd1c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate velocity field onto markers.  <a href="#aff31915ad0effdcc8dc18f602ddd1c20">More...</a><br /></td></tr>
<tr class="separator:aff31915ad0effdcc8dc18f602ddd1c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8096f9ec97cf7ce2fc45ebfcbdf3617e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_manager.html#a8096f9ec97cf7ce2fc45ebfcbdf3617e">ibm_spread</a> (int ib)</td></tr>
<tr class="memdesc:a8096f9ec97cf7ce2fc45ebfcbdf3617e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spread restorative force back onto marker support.  <a href="#a8096f9ec97cf7ce2fc45ebfcbdf3617e">More...</a><br /></td></tr>
<tr class="separator:a8096f9ec97cf7ce2fc45ebfcbdf3617e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500427b7ac8fc16eac33f804f64abdab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_manager.html#a500427b7ac8fc16eac33f804f64abdab">ibm_findsupport</a> (int ib, int m)</td></tr>
<tr class="memdesc:a500427b7ac8fc16eac33f804f64abdab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds support points for iBody.  <a href="#a500427b7ac8fc16eac33f804f64abdab">More...</a><br /></td></tr>
<tr class="separator:a500427b7ac8fc16eac33f804f64abdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5722d37636b6cd2ab92efdb6fe4bcdfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_manager.html#a5722d37636b6cd2ab92efdb6fe4bcdfa">ibm_computeforce</a> (int ib)</td></tr>
<tr class="memdesc:a5722d37636b6cd2ab92efdb6fe4bcdfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute restorative force at each marker in a body.  <a href="#a5722d37636b6cd2ab92efdb6fe4bcdfa">More...</a><br /></td></tr>
<tr class="separator:a5722d37636b6cd2ab92efdb6fe4bcdfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b544fe34e298302f3e5e8b2f981c2d8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_manager.html#a2b544fe34e298302f3e5e8b2f981c2d8">ibm_findepsilon</a> (int ib)</td></tr>
<tr class="memdesc:a2b544fe34e298302f3e5e8b2f981c2d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute epsilon for a given iBody.  <a href="#a2b544fe34e298302f3e5e8b2f981c2d8">More...</a><br /></td></tr>
<tr class="separator:a2b544fe34e298302f3e5e8b2f981c2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad874ba69d231d4c1720c4e3a68ff3499"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_manager.html#ad874ba69d231d4c1720c4e3a68ff3499">ibm_move_bodies</a> ()</td></tr>
<tr class="memdesc:ad874ba69d231d4c1720c4e3a68ff3499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves iBodies after applying IBM.  <a href="#ad874ba69d231d4c1720c4e3a68ff3499">More...</a><br /></td></tr>
<tr class="separator:ad874ba69d231d4c1720c4e3a68ff3499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad4317bfbe5bae833c4ffa3e4538d92"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_manager.html#adad4317bfbe5bae833c4ffa3e4538d92">ibm_bicgstab</a> (std::vector&lt; std::vector&lt; double &gt; &gt; &amp;Amatrix, std::vector&lt; double &gt; &amp;bVector, std::vector&lt; double &gt; &amp;epsilon, double tolerance, int maxiterations)</td></tr>
<tr class="memdesc:adad4317bfbe5bae833c4ffa3e4538d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Biconjugate gradient method.  <a href="#adad4317bfbe5bae833c4ffa3e4538d92">More...</a><br /></td></tr>
<tr class="separator:adad4317bfbe5bae833c4ffa3e4538d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956c12cba071c6b8844371c03433f82c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_manager.html#a956c12cba071c6b8844371c03433f82c">ibm_jacowire</a> (int ib)</td></tr>
<tr class="memdesc:a956c12cba071c6b8844371c03433f82c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structural calculation of flexible cilia.  <a href="#a956c12cba071c6b8844371c03433f82c">More...</a><br /></td></tr>
<tr class="separator:a956c12cba071c6b8844371c03433f82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53eedab20e69a10ae861197b614751db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_manager.html#a53eedab20e69a10ae861197b614751db">ibm_position_update</a> (int ib)</td></tr>
<tr class="memdesc:a53eedab20e69a10ae861197b614751db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the position of a deformable iBody.  <a href="#a53eedab20e69a10ae861197b614751db">More...</a><br /></td></tr>
<tr class="separator:a53eedab20e69a10ae861197b614751db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f08e2935c8999db99b41a3c97b63c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_manager.html#ae8f08e2935c8999db99b41a3c97b63c5">ibm_position_update_grp</a> (int group)</td></tr>
<tr class="memdesc:ae8f08e2935c8999db99b41a3c97b63c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the position of a group of deformable iBodies.  <a href="#ae8f08e2935c8999db99b41a3c97b63c5">More...</a><br /></td></tr>
<tr class="separator:ae8f08e2935c8999db99b41a3c97b63c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf970976700f9949bb08d8dc7f8e637"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_manager.html#a7bf970976700f9949bb08d8dc7f8e637">ibm_banbks</a> (double **a, long n, int m1, int m2, double **al, unsigned long indx[], double b[])</td></tr>
<tr class="memdesc:a7bf970976700f9949bb08d8dc7f8e637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solution of a banded diagonal linear system.  <a href="#a7bf970976700f9949bb08d8dc7f8e637">More...</a><br /></td></tr>
<tr class="separator:a7bf970976700f9949bb08d8dc7f8e637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77eb5ec758b5956e0a609fa1fba2f8e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_manager.html#a77eb5ec758b5956e0a609fa1fba2f8e8">ibm_bandec</a> (double **a, long n, int m1, int m2, double **al, unsigned long indx[], double *d)</td></tr>
<tr class="memdesc:a77eb5ec758b5956e0a609fa1fba2f8e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">LU decomposition of band diagonal matrix.  <a href="#a77eb5ec758b5956e0a609fa1fba2f8e8">More...</a><br /></td></tr>
<tr class="separator:a77eb5ec758b5956e0a609fa1fba2f8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099a446ac7f045d11d6be6babd0a31ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_manager.html#a099a446ac7f045d11d6be6babd0a31ab">bfl_build_body</a> (int body_type)</td></tr>
<tr class="memdesc:a099a446ac7f045d11d6be6babd0a31ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefab body building routine.  <a href="#a099a446ac7f045d11d6be6babd0a31ab">More...</a><br /></td></tr>
<tr class="separator:a099a446ac7f045d11d6be6babd0a31ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c65bd5122aa7e7026fb8d2315482f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_manager.html#a56c65bd5122aa7e7026fb8d2315482f3">bfl_build_body</a> (<a class="el" href="class_p_cpts.html">PCpts</a> *_PCpts)</td></tr>
<tr class="memdesc:a56c65bd5122aa7e7026fb8d2315482f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for building BFL body from point cloud.  <a href="#a56c65bd5122aa7e7026fb8d2315482f3">More...</a><br /></td></tr>
<tr class="separator:a56c65bd5122aa7e7026fb8d2315482f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a35b34d77e7cd56060a6953d0d0860a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_manager.html#a6a35b34d77e7cd56060a6953d0d0860a">computeLiftDrag</a> (int i, int j, int k, <a class="el" href="class_grid_obj.html">GridObj</a> *g)</td></tr>
<tr class="memdesc:a6a35b34d77e7cd56060a6953d0d0860a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute forces on a rigid object.  <a href="#a6a35b34d77e7cd56060a6953d0d0860a">More...</a><br /></td></tr>
<tr class="separator:a6a35b34d77e7cd56060a6953d0d0860a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39aa351c7b338473be4871111da5c5bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_manager.html#a39aa351c7b338473be4871111da5c5bd">io_vtk_IBwriter</a> (double tval)</td></tr>
<tr class="memdesc:a39aa351c7b338473be4871111da5c5bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write IB body data to VTK file.  <a href="#a39aa351c7b338473be4871111da5c5bd">More...</a><br /></td></tr>
<tr class="separator:a39aa351c7b338473be4871111da5c5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9a40c58bdb3bd9797f7c44864835ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_manager.html#a1f9a40c58bdb3bd9797f7c44864835ec">io_write_body_pos</a> (int timestep)</td></tr>
<tr class="memdesc:a1f9a40c58bdb3bd9797f7c44864835ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out position of immersed boundary bodies.  <a href="#a1f9a40c58bdb3bd9797f7c44864835ec">More...</a><br /></td></tr>
<tr class="separator:a1f9a40c58bdb3bd9797f7c44864835ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46e89c9eaf8ca1c9ec264545f39cd7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_manager.html#ab46e89c9eaf8ca1c9ec264545f39cd7f">io_write_lift_drag</a> (int timestep)</td></tr>
<tr class="memdesc:ab46e89c9eaf8ca1c9ec264545f39cd7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out forces on the markers of immersed boundary bodies.  <a href="#ab46e89c9eaf8ca1c9ec264545f39cd7f">More...</a><br /></td></tr>
<tr class="separator:ab46e89c9eaf8ca1c9ec264545f39cd7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1b7e2a3392c2a8d85606041b986b4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_manager.html#aaa1b7e2a3392c2a8d85606041b986b4d">io_restart</a> (bool IO_flag, int level)</td></tr>
<tr class="memdesc:aaa1b7e2a3392c2a8d85606041b986b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read/write IB body information to restart file.  <a href="#aaa1b7e2a3392c2a8d85606041b986b4d">More...</a><br /></td></tr>
<tr class="separator:aaa1b7e2a3392c2a8d85606041b986b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c11d747c3df9e91d5fc2dac836d7b7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_manager.html#a5c11d747c3df9e91d5fc2dac836d7b7e">io_readInCloud</a> (<a class="el" href="class_p_cpts.html">PCpts</a> *_PCpts, <a class="el" href="_object_manager_8h.html#a7b78fa3db30dfb9c1efc82bf886fe184">eObjectType</a> objtype)</td></tr>
<tr class="memdesc:a5c11d747c3df9e91d5fc2dac836d7b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in point cloud data.  <a href="#a5c11d747c3df9e91d5fc2dac836d7b7e">More...</a><br /></td></tr>
<tr class="separator:a5c11d747c3df9e91d5fc2dac836d7b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf65260d81584613fa33f2e7658f1b36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_manager.html#adf65260d81584613fa33f2e7658f1b36">io_writeForceOnObject</a> (double tval)</td></tr>
<tr class="memdesc:adf65260d81584613fa33f2e7658f1b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out the forces on a solid object.  <a href="#adf65260d81584613fa33f2e7658f1b36">More...</a><br /></td></tr>
<tr class="separator:adf65260d81584613fa33f2e7658f1b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:acf7a2f12f034c76d9e3a5aa5837dddb5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_object_manager.html">ObjectManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_manager.html#acf7a2f12f034c76d9e3a5aa5837dddb5">getInstance</a> ()</td></tr>
<tr class="memdesc:acf7a2f12f034c76d9e3a5aa5837dddb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get instance method.  <a href="#acf7a2f12f034c76d9e3a5aa5837dddb5">More...</a><br /></td></tr>
<tr class="separator:acf7a2f12f034c76d9e3a5aa5837dddb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5945decc43eb5fdeaaad101fa7aa282f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_manager.html#a5945decc43eb5fdeaaad101fa7aa282f">destroyInstance</a> ()</td></tr>
<tr class="memdesc:a5945decc43eb5fdeaaad101fa7aa282f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy instance method.  <a href="#a5945decc43eb5fdeaaad101fa7aa282f">More...</a><br /></td></tr>
<tr class="separator:a5945decc43eb5fdeaaad101fa7aa282f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c648f3d7388df47db0db9fcb4b8b618"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_object_manager.html">ObjectManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_manager.html#a3c648f3d7388df47db0db9fcb4b8b618">getInstance</a> (<a class="el" href="class_grid_obj.html">GridObj</a> *g)</td></tr>
<tr class="memdesc:a3c648f3d7388df47db0db9fcb4b8b618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded get instance passing in pointer to grid hierarchy.  <a href="#a3c648f3d7388df47db0db9fcb4b8b618">More...</a><br /></td></tr>
<tr class="separator:a3c648f3d7388df47db0db9fcb4b8b618"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a55cfec1721fb1b9d9e7592bd6288c998"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_manager.html#a55cfec1721fb1b9d9e7592bd6288c998">GridObj</a></td></tr>
<tr class="separator:a55cfec1721fb1b9d9e7592bd6288c998"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Object Manager class. </p>
<p>Class to manage all objects in the domain from creation through manipulation to destruction. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a099a446ac7f045d11d6be6babd0a31ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjectManager::bfl_build_body </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>body_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prefab body building routine. </p>
<p>Not implemented in this version.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body_type</td><td>type of prefab body to be built. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a56c65bd5122aa7e7026fb8d2315482f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjectManager::bfl_build_body </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_cpts.html">PCpts</a> *&#160;</td>
          <td class="paramname"><em>_PCpts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper for building BFL body from point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_PCpts</td><td>pointer to point cloud data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6a35b34d77e7cd56060a6953d0d0860a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjectManager::computeLiftDrag </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_grid_obj.html">GridObj</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute forces on a rigid object. </p>
<p>Uses momentum exchange to compute forces on rigid bodies. Currently working with bounce-back objects only. There is no bounding box so if we have walls in the domain they will be counted as well. Also only possible to differentiate between bodies. Lumps all bodies together.identify which body this site relates to so we can differentiate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>local i-index of solid site. </td></tr>
    <tr><td class="paramname">j</td><td>local j-index of solid site. </td></tr>
    <tr><td class="paramname">k</td><td>local k-index of solid site. </td></tr>
    <tr><td class="paramname">g</td><td>pointer to grid on which object resides. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5945decc43eb5fdeaaad101fa7aa282f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ObjectManager::destroyInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy instance method. </p>
<p>Instance destuctor. </p>

</div>
</div>
<a class="anchor" id="acf7a2f12f034c76d9e3a5aa5837dddb5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_object_manager.html">ObjectManager</a> * ObjectManager::getInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get instance method. </p>
<p>Instance creator. </p>

</div>
</div>
<a class="anchor" id="a3c648f3d7388df47db0db9fcb4b8b618"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_object_manager.html">ObjectManager</a> * ObjectManager::getInstance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_grid_obj.html">GridObj</a> *&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloaded get instance passing in pointer to grid hierarchy. </p>
<p>Instance creator with grid hierarchy assignment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>pointer to grid hierarchy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2ec2df889c396d94d2fe1807c10847bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjectManager::ibm_apply </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform IBM procedure. </p>

</div>
</div>
<a class="anchor" id="a7bf970976700f9949bb08d8dc7f8e637"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjectManager::ibm_banbks </td>
          <td>(</td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>al</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>indx</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solution of a banded diagonal linear system. </p>
<p>Given the arrays A, AL, and INDX as returned from <a class="el" href="class_object_manager.html#a77eb5ec758b5956e0a609fa1fba2f8e8" title="LU decomposition of band diagonal matrix. ">ibm_bandec()</a>, and given a right-hand side vector B[1..n], solves the band diagonal linear equations AX = B. The solution vector X overwrites B. The other input arrays are not modified, and can be left in place for successive calls with different right-hand sides. (C) Copr. 1986-92 Numerical Recipes Software ?421.1-9.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>array of subdiagonal and superdiagonals rows </td></tr>
    <tr><td class="paramname">n</td><td>size of the square matrix A </td></tr>
    <tr><td class="paramname">m1</td><td>number of subdiagonal rows </td></tr>
    <tr><td class="paramname">m2</td><td>number of superdiagonal rows </td></tr>
    <tr><td class="paramname">al</td><td>lower triangular matrix </td></tr>
    <tr><td class="paramname">indx</td><td>row permutation vector </td></tr>
    <tr><td class="paramname">b</td><td>right hand side vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a77eb5ec758b5956e0a609fa1fba2f8e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjectManager::ibm_bandec </td>
          <td>(</td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>al</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>indx</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LU decomposition of band diagonal matrix. </p>
<p>Given an n by n band diagonal matrix A with m1 subdiagonal rows and m2 superdiagonal rows, compactly stored in the array A[1..n][1..m1+m2+1] , this routine constructs an LU decomposition of a rowwise permutation of A. The upper triangular matrix replaces A, while the lower triangular matrix is returned in AL[1..n][1..m1]. INDX[1..n] is an output vector which records the row permutation effected by the partial pivoting; D is output as +/-1 depending on whether the number of row interchanges was even or odd, respectively. This routine is used in combination with <a class="el" href="class_object_manager.html#a7bf970976700f9949bb08d8dc7f8e637" title="Solution of a banded diagonal linear system. ">ibm_banbks()</a> to solve band-diagonal sets of equations. Once the matrix A has been decomposed, any number of right-hand sides can be solved in turn by repeated calls to <a class="el" href="class_object_manager.html#a7bf970976700f9949bb08d8dc7f8e637" title="Solution of a banded diagonal linear system. ">ibm_banbks()</a>. (C) Copr. 1986-92 Numerical Recipes Software ?421.1-9.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>array of subdiagonal and superdiagonals rows </td></tr>
    <tr><td class="paramname">n</td><td>size of the square matrix A </td></tr>
    <tr><td class="paramname">m1</td><td>number of subdiagonal rows </td></tr>
    <tr><td class="paramname">m2</td><td>number of superdiagonal rows </td></tr>
    <tr><td class="paramname">al</td><td>lower triangular matrix </td></tr>
    <tr><td class="paramname">indx</td><td>row permutation vector </td></tr>
    <tr><td class="paramname">d</td><td>odd or even number of row interchages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adad4317bfbe5bae833c4ffa3e4538d92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ObjectManager::ibm_bicgstab </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>Amatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>bVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxiterations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Biconjugate gradient method. </p>
<p>Biconjugate gradient stabilised method of solving a linear system Ax = b. Solution is performed iteratively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Amatrix</td><td>the A matrix in the linear system. </td></tr>
    <tr><td class="paramname">bVector</td><td>the b vector in the linear system. </td></tr>
    <tr><td class="paramname">epsilon</td><td>epsilon paramters for each marker. </td></tr>
    <tr><td class="paramname">tolerance</td><td>tolerance of solution. </td></tr>
    <tr><td class="paramname">maxiterations</td><td>maximum number of iterations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum residual achieved by the solver. </dd></dl>

</div>
</div>
<a class="anchor" id="af89336910b6f3157e5b17b4ea6d30a12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjectManager::ibm_build_body </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>body_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a prefab immersed boundary body. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body_type</td><td>type of body to be built. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac8270fe5b646e512a34748b5ca51671c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjectManager::ibm_build_body </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_cpts.html">PCpts</a> *&#160;</td>
          <td class="paramname"><em>_PCpts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_grid_obj.html">GridObj</a> *&#160;</td>
          <td class="paramname"><em>owner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper for building a body from a point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_PCpts</td><td>pointer to point cloud data. </td></tr>
    <tr><td class="paramname">owner</td><td>pointer to the grid on which the body is to be placed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5722d37636b6cd2ab92efdb6fe4bcdfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjectManager::ibm_computeforce </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ib</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute restorative force at each marker in a body. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ib</td><td>iBody being operated on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4e55e3a84bae37a75f8487fd575169fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ObjectManager::ibm_deltakernel </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dilation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to evaluate delta kernel at supplied location. </p>
<p>Radius and dilation must be in the same units.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radius</td><td>location at which kernel should be evaluated. </td></tr>
    <tr><td class="paramname">dilation</td><td>width of kernel function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of kernel function. </dd></dl>

</div>
</div>
<a class="anchor" id="a2b544fe34e298302f3e5e8b2f981c2d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ObjectManager::ibm_findepsilon </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ib</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute epsilon for a given iBody. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ib</td><td>iBody being operated on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a500427b7ac8fc16eac33f804f64abdab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjectManager::ibm_findsupport </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds support points for iBody. </p>
<p>Support for given marker in given body is sought on the owning grid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ib</td><td>body under consideration. </td></tr>
    <tr><td class="paramname">m</td><td>marker whose support is to be found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa4e5e286a6fe1d9fcaf393ffed329250"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjectManager::ibm_initialise </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise the array of iBodies. </p>
<p>Computes support and epsilon values. </p>

</div>
</div>
<a class="anchor" id="aff31915ad0effdcc8dc18f602ddd1c20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjectManager::ibm_interpol </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ib</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate velocity field onto markers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ib</td><td>iBody being operated on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a956c12cba071c6b8844371c03433f82c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjectManager::ibm_jacowire </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ib</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Structural calculation of flexible cilia. </p>
<p>Models the structural behaviour of a thin wire using Euler-Bernoulli beam elements. Only implemented for one simply supported end and one free end at present.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ib</td><td>index of body to which calculation is to be applied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad874ba69d231d4c1720c4e3a68ff3499"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjectManager::ibm_move_bodies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves iBodies after applying IBM. </p>
<p>Wrapper for relocating markers of an iBody be calling appropriate positional update routine. </p>

</div>
</div>
<a class="anchor" id="a53eedab20e69a10ae861197b614751db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjectManager::ibm_position_update </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ib</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the position of a deformable iBody. </p>
<p>Wrapper for applying external forcing or structural calculations to iBodies marked as deformable. Updates support on completion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ib</td><td>index of body to which calculation is to be applied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae8f08e2935c8999db99b41a3c97b63c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjectManager::ibm_position_update_grp </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the position of a group of deformable iBodies. </p>
<p>Updates the position of a group of non-flexible moving (deformable) bodies by using the first flexible body in the group as the driver. Must be called after all previous positional update routines have been called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>group ID to be updated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8096f9ec97cf7ce2fc45ebfcbdf3617e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjectManager::ibm_spread </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ib</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Spread restorative force back onto marker support. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ib</td><td>iBody being operated on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5c11d747c3df9e91d5fc2dac836d7b7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjectManager::io_readInCloud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_cpts.html">PCpts</a> *&#160;</td>
          <td class="paramname"><em>_PCpts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_object_manager_8h.html#a7b78fa3db30dfb9c1efc82bf886fe184">eObjectType</a>&#160;</td>
          <td class="paramname"><em>objtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read in point cloud data. </p>
<p>Input data must be in tab separated, 3-column format in the input directory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_PCpts</td><td>pointer to empty point cloud data container. </td></tr>
    <tr><td class="paramname">objtype</td><td>type of object to be read in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa1b7e2a3392c2a8d85606041b986b4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjectManager::io_restart </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>IO_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read/write IB body information to restart file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">IO_flag</td><td>flag indicating write (true) or read (false). </td></tr>
    <tr><td class="paramname">level</td><td>level of the grid begin written/read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a39aa351c7b338473be4871111da5c5bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjectManager::io_vtk_IBwriter </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write IB body data to VTK file. </p>
<p>Currently can only write out un-closed bodies like filaments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tval</td><td>time value at which the write out is being performed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1f9a40c58bdb3bd9797f7c44864835ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjectManager::io_write_body_pos </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timestep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write out position of immersed boundary bodies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timestep</td><td>timestep at which the write out is being performed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab46e89c9eaf8ca1c9ec264545f39cd7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjectManager::io_write_lift_drag </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timestep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write out forces on the markers of immersed boundary bodies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timestep</td><td>timestep at which the write out is being performed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adf65260d81584613fa33f2e7658f1b36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ObjectManager::io_writeForceOnObject </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write out the forces on a solid object. </p>
<p>Writes out the forces on solid objects in the domain computed using momentum exchange. Each rank writes its own file. Output is a CSV file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tval</td><td>time value at which write out is taking place. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a55cfec1721fb1b9d9e7592bd6288c998"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_grid_obj.html">GridObj</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_object_manager_8h_source.html">ObjectManager.h</a></li>
<li><a class="el" href="_object_manager_8cpp.html">ObjectManager.cpp</a></li>
<li><a class="el" href="_object_manager__init__bflbody_8cpp.html">ObjectManager_init_bflbody.cpp</a></li>
<li><a class="el" href="_object_manager__init__ibmbody_8cpp.html">ObjectManager_init_ibmbody.cpp</a></li>
<li><a class="el" href="_object_manager__ops__ibm_8cpp.html">ObjectManager_ops_ibm.cpp</a></li>
<li><a class="el" href="_object_manager__ops__ibmflex_8cpp.html">ObjectManager_ops_ibmflex.cpp</a></li>
<li><a class="el" href="_object_manager__ops__io_8cpp.html">ObjectManager_ops_io.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
