<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>LUMA: GridUtils Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="lumalogo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LUMA
   &#160;<span id="projectnumber">1.4.0-alpha</span>
   </div>
   <div id="projectbrief">2D/3D FSI lattice Boltzmann solver for CPU</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="class_grid_utils-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">GridUtils Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Grid utility class.  
 <a href="class_grid_utils.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_grid_utils_8h_source.html">GridUtils.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af931614cb5eab6b906aa01106089b628"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#af931614cb5eab6b906aa01106089b628">createOutputDirectory</a> (std::string <a class="el" href="class_grid_utils.html#a9b58748e9e05e84852962d7abc7942e3">path_str</a>)</td></tr>
<tr class="memdesc:af931614cb5eab6b906aa01106089b628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create output directory.  <a href="#af931614cb5eab6b906aa01106089b628">More...</a><br /></td></tr>
<tr class="separator:af931614cb5eab6b906aa01106089b628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f0d4a76be76a743c368c9a1d4d46cbc"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#a1f0d4a76be76a743c368c9a1d4d46cbc">onespace</a> (int min, int max)</td></tr>
<tr class="memdesc:a1f0d4a76be76a743c368c9a1d4d46cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a linearly-spaced vector of integers.  <a href="#a1f0d4a76be76a743c368c9a1d4d46cbc">More...</a><br /></td></tr>
<tr class="separator:a1f0d4a76be76a743c368c9a1d4d46cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f172a6dd8b2749ca1c8336a64a07e29"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#a2f172a6dd8b2749ca1c8336a64a07e29">linspace</a> (double min, double max, int n)</td></tr>
<tr class="memdesc:a2f172a6dd8b2749ca1c8336a64a07e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a linearly-spaced vector of values.  <a href="#a2f172a6dd8b2749ca1c8336a64a07e29">More...</a><br /></td></tr>
<tr class="separator:a2f172a6dd8b2749ca1c8336a64a07e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0d0da69ec1543835b98bca884f8927"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#a1e0d0da69ec1543835b98bca884f8927">vecnorm</a> (double vec[<a class="el" href="definitions_8h.html#a31d5945080ee5c34edc32e6f74c724c8">L_DIMS</a>])</td></tr>
<tr class="memdesc:a1e0d0da69ec1543835b98bca884f8927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the L2 norm using the vector supplied.  <a href="#a1e0d0da69ec1543835b98bca884f8927">More...</a><br /></td></tr>
<tr class="separator:a1e0d0da69ec1543835b98bca884f8927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d797edf50b3c3a448d59684a135aee"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#ae7d797edf50b3c3a448d59684a135aee">vecnorm</a> (double val1, double val2)</td></tr>
<tr class="memdesc:ae7d797edf50b3c3a448d59684a135aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the L2 norm using the vector components supplied.  <a href="#ae7d797edf50b3c3a448d59684a135aee">More...</a><br /></td></tr>
<tr class="separator:ae7d797edf50b3c3a448d59684a135aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6caced99b15b01746c1fb5828c447034"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#a6caced99b15b01746c1fb5828c447034">vecnorm</a> (double val1, double val2, double val3)</td></tr>
<tr class="memdesc:a6caced99b15b01746c1fb5828c447034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the L2 norm using the vector components supplied.  <a href="#a6caced99b15b01746c1fb5828c447034">More...</a><br /></td></tr>
<tr class="separator:a6caced99b15b01746c1fb5828c447034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45167f9bde2e34d868a4ccc64f588ab2"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#a45167f9bde2e34d868a4ccc64f588ab2">vecnorm</a> (std::vector&lt; double &gt; vec)</td></tr>
<tr class="memdesc:a45167f9bde2e34d868a4ccc64f588ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the L2 norm using the vector supplied.  <a href="#a45167f9bde2e34d868a4ccc64f588ab2">More...</a><br /></td></tr>
<tr class="separator:a45167f9bde2e34d868a4ccc64f588ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee47fe58eccee5fffd67bb489fd1c315"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#aee47fe58eccee5fffd67bb489fd1c315">getFineIndices</a> (int coarse_i, int x_start, int coarse_j, int y_start, int coarse_k, int z_start)</td></tr>
<tr class="memdesc:aee47fe58eccee5fffd67bb489fd1c315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the indices of the fine site given the coarse site.  <a href="#aee47fe58eccee5fffd67bb489fd1c315">More...</a><br /></td></tr>
<tr class="separator:aee47fe58eccee5fffd67bb489fd1c315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3973d2b60fe6cac6e49e8640307958"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#a4d3973d2b60fe6cac6e49e8640307958">getCoarseIndices</a> (int fine_i, int x_start, int fine_j, int y_start, int fine_k, int z_start)</td></tr>
<tr class="memdesc:a4d3973d2b60fe6cac6e49e8640307958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the indices of the coarse site given the fine site.  <a href="#a4d3973d2b60fe6cac6e49e8640307958">More...</a><br /></td></tr>
<tr class="separator:a4d3973d2b60fe6cac6e49e8640307958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af374256beaf42d97b23f7d98af93a3f1"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#af374256beaf42d97b23f7d98af93a3f1">dotprod</a> (std::vector&lt; double &gt; vec1, std::vector&lt; double &gt; vec2)</td></tr>
<tr class="memdesc:af374256beaf42d97b23f7d98af93a3f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the scalar product of two vectors.  <a href="#af374256beaf42d97b23f7d98af93a3f1">More...</a><br /></td></tr>
<tr class="separator:af374256beaf42d97b23f7d98af93a3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5af65d6bb25e0d34be50670b41514f"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#a6f5af65d6bb25e0d34be50670b41514f">subtract</a> (std::vector&lt; double &gt; a, std::vector&lt; double &gt; b)</td></tr>
<tr class="memdesc:a6f5af65d6bb25e0d34be50670b41514f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts two vectors.  <a href="#a6f5af65d6bb25e0d34be50670b41514f">More...</a><br /></td></tr>
<tr class="separator:a6f5af65d6bb25e0d34be50670b41514f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9fc081a19660e9db39428014c04a9c"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#a4e9fc081a19660e9db39428014c04a9c">add</a> (std::vector&lt; double &gt; a, std::vector&lt; double &gt; b)</td></tr>
<tr class="memdesc:a4e9fc081a19660e9db39428014c04a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds two vectors.  <a href="#a4e9fc081a19660e9db39428014c04a9c">More...</a><br /></td></tr>
<tr class="separator:a4e9fc081a19660e9db39428014c04a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01eba1d90d3414637d5031850ad89ce3"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#a01eba1d90d3414637d5031850ad89ce3">vecmultiply</a> (double scalar, std::vector&lt; double &gt; vec)</td></tr>
<tr class="memdesc:a01eba1d90d3414637d5031850ad89ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies a scalar by a vector.  <a href="#a01eba1d90d3414637d5031850ad89ce3">More...</a><br /></td></tr>
<tr class="separator:a01eba1d90d3414637d5031850ad89ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb315c03a681483339de9f60ab2964d6"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#aeb315c03a681483339de9f60ab2964d6">crossprod</a> (std::vector&lt; double &gt; vec1, std::vector&lt; double &gt; vec2)</td></tr>
<tr class="memdesc:aeb315c03a681483339de9f60ab2964d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes vector product.  <a href="#aeb315c03a681483339de9f60ab2964d6">More...</a><br /></td></tr>
<tr class="separator:aeb315c03a681483339de9f60ab2964d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0051918813c63802d79bd7d172e8ad8a"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#a0051918813c63802d79bd7d172e8ad8a">matrix_multiply</a> (const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;A, const std::vector&lt; double &gt; &amp;x)</td></tr>
<tr class="memdesc:a0051918813c63802d79bd7d172e8ad8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies matrix A by vector x.  <a href="#a0051918813c63802d79bd7d172e8ad8a">More...</a><br /></td></tr>
<tr class="separator:a0051918813c63802d79bd7d172e8ad8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c54e468658879756c71b01abd028d5"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#af3c54e468658879756c71b01abd028d5">getOpposite</a> (int direction)</td></tr>
<tr class="memdesc:af3c54e468658879756c71b01abd028d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the opposite lattice direction to the one supplied.  <a href="#af3c54e468658879756c71b01abd028d5">More...</a><br /></td></tr>
<tr class="separator:af3c54e468658879756c71b01abd028d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac10170d3f6f96a32da6a783b815954"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#afac10170d3f6f96a32da6a783b815954">getGrid</a> (<a class="el" href="class_grid_obj.html">GridObj</a> *&amp;Grids, int level, int region, <a class="el" href="class_grid_obj.html">GridObj</a> *&amp;ptr)</td></tr>
<tr class="memdesc:afac10170d3f6f96a32da6a783b815954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to a given grid in the hierarchy.  <a href="#afac10170d3f6f96a32da6a783b815954">More...</a><br /></td></tr>
<tr class="separator:afac10170d3f6f96a32da6a783b815954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c13884020ab181ee8cb6dd2ea7e4fd7"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#a7c13884020ab181ee8cb6dd2ea7e4fd7">isOverlapPeriodic</a> (int i, int j, int k, const <a class="el" href="class_grid_obj.html">GridObj</a> &amp;pGrid)</td></tr>
<tr class="memdesc:a7c13884020ab181ee8cb6dd2ea7e4fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds out whether halo containng i,j,k links to neighbour rank periodically.  <a href="#a7c13884020ab181ee8cb6dd2ea7e4fd7">More...</a><br /></td></tr>
<tr class="separator:a7c13884020ab181ee8cb6dd2ea7e4fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf9512bd143ac0b9ef7eec33f1510ec"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#adcf9512bd143ac0b9ef7eec33f1510ec">isOnThisRank</a> (double x, double y, double z, <a class="el" href="_grid_utils_8h.html#a478f1e2cf9934de79a892e60980598dc">eLocationOnRank</a> loc=<a class="el" href="_grid_utils_8h.html#a478f1e2cf9934de79a892e60980598dca6505acf15690a324459e652a94fc339a">eNone</a>, const <a class="el" href="class_grid_obj.html">GridObj</a> *grid=nullptr, std::vector&lt; int &gt; *pos=nullptr)</td></tr>
<tr class="memdesc:adcf9512bd143ac0b9ef7eec33f1510ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds out whether site with supplied position is on the current rank.  <a href="#adcf9512bd143ac0b9ef7eec33f1510ec">More...</a><br /></td></tr>
<tr class="separator:adcf9512bd143ac0b9ef7eec33f1510ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eca1ee0dff756b5cd65d45f84b24118"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#a4eca1ee0dff756b5cd65d45f84b24118">isOnThisRank</a> (double xyz, <a class="el" href="_grid_utils_8h.html#afbad8e4a2f1e9903755b1bd2fe8273cf">eCartesianDirection</a> dir, <a class="el" href="_grid_utils_8h.html#a478f1e2cf9934de79a892e60980598dc">eLocationOnRank</a> loc=<a class="el" href="_grid_utils_8h.html#a478f1e2cf9934de79a892e60980598dca6505acf15690a324459e652a94fc339a">eNone</a>, const <a class="el" href="class_grid_obj.html">GridObj</a> *grid=nullptr, int *pos=nullptr)</td></tr>
<tr class="memdesc:a4eca1ee0dff756b5cd65d45f84b24118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds out whether the supplied position can be found on the current rank.  <a href="#a4eca1ee0dff756b5cd65d45f84b24118">More...</a><br /></td></tr>
<tr class="separator:a4eca1ee0dff756b5cd65d45f84b24118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14da5d778eb6d81fbcd5c9331a8082dd"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#a14da5d778eb6d81fbcd5c9331a8082dd">intersectsRefinedRegion</a> (const <a class="el" href="class_grid_obj.html">GridObj</a> &amp;pGrid, int RegNum)</td></tr>
<tr class="memdesc:a14da5d778eb6d81fbcd5c9331a8082dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds out whether all or part of specified refined region intersects with the space occupied by the grid provided.  <a href="#a14da5d778eb6d81fbcd5c9331a8082dd">More...</a><br /></td></tr>
<tr class="separator:a14da5d778eb6d81fbcd5c9331a8082dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0692236725709af2d98872805fc84ae"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#af0692236725709af2d98872805fc84ae">isOnSenderLayer</a> (double pos_x, double pos_y, double pos_z)</td></tr>
<tr class="memdesc:af0692236725709af2d98872805fc84ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether site is on an inner (sender) halo.  <a href="#af0692236725709af2d98872805fc84ae">More...</a><br /></td></tr>
<tr class="separator:af0692236725709af2d98872805fc84ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfec29d90b6942de2f3c52c225a4d888"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#abfec29d90b6942de2f3c52c225a4d888">isOnRecvLayer</a> (double pos_x, double pos_y, double pos_z)</td></tr>
<tr class="memdesc:abfec29d90b6942de2f3c52c225a4d888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether site is on an outer (receiver) halo.  <a href="#abfec29d90b6942de2f3c52c225a4d888">More...</a><br /></td></tr>
<tr class="separator:abfec29d90b6942de2f3c52c225a4d888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9179e27b25b1be249edd6d22455d57bd"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#a9179e27b25b1be249edd6d22455d57bd">isOnSenderLayer</a> (double site_position, <a class="el" href="_grid_utils_8h.html#a0cc91691e907a6a03b129d18a62fe33d">eCartMinMax</a> edge)</td></tr>
<tr class="memdesc:a9179e27b25b1be249edd6d22455d57bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether site is on an inner (sender) halo.  <a href="#a9179e27b25b1be249edd6d22455d57bd">More...</a><br /></td></tr>
<tr class="separator:a9179e27b25b1be249edd6d22455d57bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381a3ef0d42132313081b5c06f732092"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#a381a3ef0d42132313081b5c06f732092">isOnRecvLayer</a> (double site_position, <a class="el" href="_grid_utils_8h.html#a0cc91691e907a6a03b129d18a62fe33d">eCartMinMax</a> edge)</td></tr>
<tr class="memdesc:a381a3ef0d42132313081b5c06f732092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether site is on an outer (receiver) halo.  <a href="#a381a3ef0d42132313081b5c06f732092">More...</a><br /></td></tr>
<tr class="separator:a381a3ef0d42132313081b5c06f732092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a59da2eb58afd9e785b45b23ad962df"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#a1a59da2eb58afd9e785b45b23ad962df">getMpiDirection</a> (int offset_vector[])</td></tr>
<tr class="memdesc:a1a59da2eb58afd9e785b45b23ad962df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get direction in MPI topology from unit vector.  <a href="#a1a59da2eb58afd9e785b45b23ad962df">More...</a><br /></td></tr>
<tr class="separator:a1a59da2eb58afd9e785b45b23ad962df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb35c1a485e74c0b2794b84573b5e50f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#acb35c1a485e74c0b2794b84573b5e50f">isOffGrid</a> (int i, int j, int k, const <a class="el" href="class_grid_obj.html">GridObj</a> *g)</td></tr>
<tr class="memdesc:acb35c1a485e74c0b2794b84573b5e50f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether a site is on a given grid.  <a href="#acb35c1a485e74c0b2794b84573b5e50f">More...</a><br /></td></tr>
<tr class="separator:acb35c1a485e74c0b2794b84573b5e50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c030776101d001fda37eb7f90d2b20"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#ad0c030776101d001fda37eb7f90d2b20">getEnclosingVoxel</a> (double x, double y, double z, const <a class="el" href="class_grid_obj.html">GridObj</a> *g, std::vector&lt; int &gt; *ijk)</td></tr>
<tr class="memdesc:ad0c030776101d001fda37eb7f90d2b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get local voxel indices on grid in which provided position lies.  <a href="#ad0c030776101d001fda37eb7f90d2b20">More...</a><br /></td></tr>
<tr class="separator:ad0c030776101d001fda37eb7f90d2b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20901145122cf56507713abe0467638c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#a20901145122cf56507713abe0467638c">getEnclosingVoxel</a> (double x, const <a class="el" href="class_grid_obj.html">GridObj</a> *g, <a class="el" href="_grid_utils_8h.html#afbad8e4a2f1e9903755b1bd2fe8273cf">eCartesianDirection</a> dir, int *ijk)</td></tr>
<tr class="memdesc:a20901145122cf56507713abe0467638c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get local voxel indices on grid in which provided position lies.  <a href="#a20901145122cf56507713abe0467638c">More...</a><br /></td></tr>
<tr class="separator:a20901145122cf56507713abe0467638c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d9c31d1c15198d1455627d1fa29804"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#a78d9c31d1c15198d1455627d1fa29804">isOnTransitionLayer</a> (double pos_x, double pos_y, double pos_z, const <a class="el" href="class_grid_obj.html">GridObj</a> *grid)</td></tr>
<tr class="memdesc:a78d9c31d1c15198d1455627d1fa29804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether site is on a TL.  <a href="#a78d9c31d1c15198d1455627d1fa29804">More...</a><br /></td></tr>
<tr class="separator:a78d9c31d1c15198d1455627d1fa29804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99e3fa97dcb3be1f6b88a55f232c2cd"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#ae99e3fa97dcb3be1f6b88a55f232c2cd">isOnTransitionLayer</a> (double position, <a class="el" href="_grid_utils_8h.html#a0cc91691e907a6a03b129d18a62fe33d">eCartMinMax</a> edge, const <a class="el" href="class_grid_obj.html">GridObj</a> *grid)</td></tr>
<tr class="memdesc:ae99e3fa97dcb3be1f6b88a55f232c2cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether site is on a specific TL (to upper).  <a href="#ae99e3fa97dcb3be1f6b88a55f232c2cd">More...</a><br /></td></tr>
<tr class="separator:ae99e3fa97dcb3be1f6b88a55f232c2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78aa4876d7066bce253c52457e7b901d"><td class="memTemplParams" colspan="2">template&lt;typename NumType &gt; </td></tr>
<tr class="memitem:a78aa4876d7066bce253c52457e7b901d"><td class="memTemplItemLeft" align="right" valign="top">static NumType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#a78aa4876d7066bce253c52457e7b901d">vecnorm</a> (NumType a1, NumType a2, NumType a3)</td></tr>
<tr class="memdesc:a78aa4876d7066bce253c52457e7b901d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the L2-norm.  <a href="#a78aa4876d7066bce253c52457e7b901d">More...</a><br /></td></tr>
<tr class="separator:a78aa4876d7066bce253c52457e7b901d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a169fc043a585f20936b314def45fe7"><td class="memTemplParams" colspan="2">template&lt;typename NumType &gt; </td></tr>
<tr class="memitem:a7a169fc043a585f20936b314def45fe7"><td class="memTemplItemLeft" align="right" valign="top">static NumType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#a7a169fc043a585f20936b314def45fe7">vecnorm</a> (NumType a1, NumType a2)</td></tr>
<tr class="memdesc:a7a169fc043a585f20936b314def45fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the L2-norm.  <a href="#a7a169fc043a585f20936b314def45fe7">More...</a><br /></td></tr>
<tr class="separator:a7a169fc043a585f20936b314def45fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3e26a94e62833f0a9e5a4bda066dac"><td class="memTemplParams" colspan="2">template&lt;typename NumType &gt; </td></tr>
<tr class="memitem:a5a3e26a94e62833f0a9e5a4bda066dac"><td class="memTemplItemLeft" align="right" valign="top">static NumType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#a5a3e26a94e62833f0a9e5a4bda066dac">upToZero</a> (NumType x)</td></tr>
<tr class="memdesc:a5a3e26a94e62833f0a9e5a4bda066dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds a negative value up to zero.  <a href="#a5a3e26a94e62833f0a9e5a4bda066dac">More...</a><br /></td></tr>
<tr class="separator:a5a3e26a94e62833f0a9e5a4bda066dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4068e22339d5272ca551f8cbddec26"><td class="memTemplParams" colspan="2">template&lt;typename NumType &gt; </td></tr>
<tr class="memitem:abd4068e22339d5272ca551f8cbddec26"><td class="memTemplItemLeft" align="right" valign="top">static NumType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#abd4068e22339d5272ca551f8cbddec26">downToLimit</a> (NumType x, NumType limit)</td></tr>
<tr class="memdesc:abd4068e22339d5272ca551f8cbddec26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds a value greater than a limit down to this value.  <a href="#abd4068e22339d5272ca551f8cbddec26">More...</a><br /></td></tr>
<tr class="separator:abd4068e22339d5272ca551f8cbddec26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57edeaeba2d67d187a9edd0b560fe0c2"><td class="memTemplParams" colspan="2">template&lt;typename NumType &gt; </td></tr>
<tr class="memitem:a57edeaeba2d67d187a9edd0b560fe0c2"><td class="memTemplItemLeft" align="right" valign="top">static NumType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#a57edeaeba2d67d187a9edd0b560fe0c2">factorial</a> (NumType n)</td></tr>
<tr class="memdesc:a57edeaeba2d67d187a9edd0b560fe0c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the factorial of the supplied value.  <a href="#a57edeaeba2d67d187a9edd0b560fe0c2">More...</a><br /></td></tr>
<tr class="separator:a57edeaeba2d67d187a9edd0b560fe0c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ca6e20ef4fa927cb845956d7565b1e"><td class="memTemplParams" colspan="2">template&lt;typename NumType &gt; </td></tr>
<tr class="memitem:aa3ca6e20ef4fa927cb845956d7565b1e"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#aa3ca6e20ef4fa927cb845956d7565b1e">stridedCopy</a> (NumType *dest, NumType *src, size_t block, size_t offset, size_t stride, size_t count, size_t buf_offset=0)</td></tr>
<tr class="memdesc:aa3ca6e20ef4fa927cb845956d7565b1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a strided memcpy.  <a href="#aa3ca6e20ef4fa927cb845956d7565b1e">More...</a><br /></td></tr>
<tr class="separator:aa3ca6e20ef4fa927cb845956d7565b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a298239096e929c1ba4eba925e351c1b3"><td class="memItemLeft" align="right" valign="top">static std::ofstream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#a298239096e929c1ba4eba925e351c1b3">logfile</a></td></tr>
<tr class="memdesc:a298239096e929c1ba4eba925e351c1b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle to output file.  <a href="#a298239096e929c1ba4eba925e351c1b3">More...</a><br /></td></tr>
<tr class="separator:a298239096e929c1ba4eba925e351c1b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b58748e9e05e84852962d7abc7942e3"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#a9b58748e9e05e84852962d7abc7942e3">path_str</a></td></tr>
<tr class="memdesc:a9b58748e9e05e84852962d7abc7942e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static string representing output path.  <a href="#a9b58748e9e05e84852962d7abc7942e3">More...</a><br /></td></tr>
<tr class="separator:a9b58748e9e05e84852962d7abc7942e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b566735d973bc25f1a6416010efa70"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_utils.html#ae2b566735d973bc25f1a6416010efa70">dir_reflect</a> [<a class="el" href="definitions_8h.html#a31d5945080ee5c34edc32e6f74c724c8">L_DIMS</a> *2][<a class="el" href="definitions_8h.html#a947c7e248feb63ae57fb828c03c4c001">L_NUM_VELS</a>]</td></tr>
<tr class="memdesc:ae2b566735d973bc25f1a6416010efa70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array with hardcoded direction numbering for specular reflection.  <a href="#ae2b566735d973bc25f1a6416010efa70">More...</a><br /></td></tr>
<tr class="separator:ae2b566735d973bc25f1a6416010efa70"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Grid utility class. </p>
<p>Class provides grid utilities including commonly used logical tests. This is a static class and so there is no need to instantiate it. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4e9fc081a19660e9db39428014c04a9c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; GridUtils::add </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds two vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>a vector. </td></tr>
    <tr><td class="paramname">b</td><td>a second vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector which is a + b. </dd></dl>

</div>
</div>
<a class="anchor" id="af931614cb5eab6b906aa01106089b628"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GridUtils::createOutputDirectory </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path_str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create output directory. </p>
<p>Compatible with both Windows and Linux. Filename and path passed as a single string. Returns nothing at the moment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path_str</td><td>full path and filename as string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>indicator of status of action. </dd></dl>

</div>
</div>
<a class="anchor" id="aeb315c03a681483339de9f60ab2964d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; GridUtils::crossprod </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes vector product. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>a vector. </td></tr>
    <tr><td class="paramname">b</td><td>a second vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector which is the cross product of a and b. </dd></dl>

</div>
</div>
<a class="anchor" id="af374256beaf42d97b23f7d98af93a3f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double GridUtils::dotprod </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the scalar product of two vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>a vector. </td></tr>
    <tr><td class="paramname">vec2</td><td>a second vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the dot product of the two vectors. </dd></dl>

</div>
</div>
<a class="anchor" id="abd4068e22339d5272ca551f8cbddec26"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static NumType GridUtils::downToLimit </td>
          <td>(</td>
          <td class="paramtype">NumType&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumType&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds a value greater than a limit down to this value. </p>
<p>If value is less than or equal to the limit, return the value unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>value to be rounded </td></tr>
    <tr><td class="paramname">limit</td><td>value to be rounded down to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NumType rounded value </dd></dl>

</div>
</div>
<a class="anchor" id="a57edeaeba2d67d187a9edd0b560fe0c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static NumType GridUtils::factorial </td>
          <td>(</td>
          <td class="paramtype">NumType&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the factorial of the supplied value. </p>
<p>If n == 0 then returns 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>factorial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NumType n factorial </dd></dl>

</div>
</div>
<a class="anchor" id="a4d3973d2b60fe6cac6e49e8640307958"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; GridUtils::getCoarseIndices </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fine_i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fine_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fine_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>z_start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the indices of the coarse site given the fine site. </p>
<p>Maps the indices of a fine grid site to a corresponding coarse site on the level above.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fine_i</td><td>local i-index of fine site to be mapped. </td></tr>
    <tr><td class="paramname">x_start</td><td>local x-index of start of refined region on the grid above. </td></tr>
    <tr><td class="paramname">fine_j</td><td>local j-index of fine site to be mapped. </td></tr>
    <tr><td class="paramname">y_start</td><td>local y-index of start of refined region on the grid above. </td></tr>
    <tr><td class="paramname">fine_k</td><td>local k-index of fine site to be mapped. </td></tr>
    <tr><td class="paramname">z_start</td><td>local z-index of start of refined region on the grid above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>local indices of the coarse grid site. </dd></dl>

</div>
</div>
<a class="anchor" id="ad0c030776101d001fda37eb7f90d2b20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GridUtils::getEnclosingVoxel </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_grid_obj.html">GridObj</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>ijk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get local voxel indices on grid in which provided position lies. </p>
<p>Wrapper for the overload which concentates all check into a vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>x-position. </td></tr>
    <tr><td class="paramname">y</td><td>y-position. </td></tr>
    <tr><td class="paramname">z</td><td>z-position. </td></tr>
    <tr><td class="paramname">g</td><td>lattice on which to look for enclosing voxel. </td></tr>
    <tr><td class="paramname">ijk</td><td>pointer to vector where indices are to be placed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a20901145122cf56507713abe0467638c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GridUtils::getEnclosingVoxel </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_grid_obj.html">GridObj</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_grid_utils_8h.html#afbad8e4a2f1e9903755b1bd2fe8273cf">eCartesianDirection</a>&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ijk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get local voxel indices on grid in which provided position lies. </p>
<p>Will return the 1D voxel index of the voxel on the lattice provided within which point with position (xyz) lies. This is done by rounding the position to obtain how many voxels in from the grid core edge it is, then accounting for whether the grid starts on another rank, in the halo, or further into the grid by offsetting the original index by this amount. This approach saves expensive seraches of the position vectors on each grid. This method can be used as a position -&gt; voxel converter. The index may be off grid so it is advisable to call isOnThisRank instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xyz</td><td>x, y or z-position. </td></tr>
    <tr><td class="paramname">g</td><td>lattice on which to look for enclosing voxel. </td></tr>
    <tr><td class="paramname">dir</td><td>1D direction. </td></tr>
    <tr><td class="paramname">ijk</td><td>pointer to local index storage location. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aee47fe58eccee5fffd67bb489fd1c315"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; GridUtils::getFineIndices </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>coarse_i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>coarse_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>coarse_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>z_start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the indices of the fine site given the coarse site. </p>
<p>Maps the indices of a coarse grid site to a corresponding fine site on the level below.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coarse_i</td><td>local i-index of coarse site to be mapped. </td></tr>
    <tr><td class="paramname">x_start</td><td>local x-index of start of refined region. </td></tr>
    <tr><td class="paramname">coarse_j</td><td>local j-index of coarse site to be mapped. </td></tr>
    <tr><td class="paramname">y_start</td><td>local y-index of start of refined region. </td></tr>
    <tr><td class="paramname">coarse_k</td><td>local k-index of coarse site to be mapped. </td></tr>
    <tr><td class="paramname">z_start</td><td>local z-index of start of refined region. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>local indices of the fine grid site. </dd></dl>

</div>
</div>
<a class="anchor" id="afac10170d3f6f96a32da6a783b815954"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GridUtils::getGrid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_grid_obj.html">GridObj</a> *&amp;&#160;</td>
          <td class="paramname"><em>Grids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_grid_obj.html">GridObj</a> *&amp;&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to a given grid in the hierarchy. </p>
<p>Takes a NULL pointer by reference and updates it when matching grid is found in hierarchy on this rank. If grid not found, pointer is returned without change and stays NULL. Can be used to test for the existence of a grid on a rank by passing in a NULL pointer and checking if a NULL pointer is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">Grids</td><td>x-position of site. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">level</td><td>y-position of site. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">region</td><td>z-position of site. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ptr</td><td>pointer containing address of grid in hierarchy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1a59da2eb58afd9e785b45b23ad962df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int GridUtils::getMpiDirection </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset_vector</em>[]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get direction in MPI topology from unit vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset_vector</td><td>unit vector pointing away from current rank. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MPI direction. </dd></dl>

</div>
</div>
<a class="anchor" id="af3c54e468658879756c71b01abd028d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int GridUtils::getOpposite </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>direction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the opposite lattice direction to the one supplied. </p>
<p>This is model independent as long as the model directions are specified such that the oppoiste direction is either one vector on or one vector back in the listing depending on whether the direction supplied is even or odd.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">direction</td><td>direction to be reversed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>opposite direction in lattice model. </dd></dl>

</div>
</div>
<a class="anchor" id="a14da5d778eb6d81fbcd5c9331a8082dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GridUtils::intersectsRefinedRegion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_grid_obj.html">GridObj</a> &amp;&#160;</td>
          <td class="paramname"><em>pGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>RegNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds out whether all or part of specified refined region intersects with the space occupied by the grid provided. </p>
<p>Prinicpal use is for sub-grid initialisation to determine whether a sub-grid needs adding or not. This decision is made based on whether any part of the grid is covered by the discrete voxels of existing grids on the rank.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pGrid</td><td>parent grid at appropriate level. </td></tr>
    <tr><td class="paramname">RegNum</td><td>region number desired. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean answer. </dd></dl>

</div>
</div>
<a class="anchor" id="acb35c1a485e74c0b2794b84573b5e50f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GridUtils::isOffGrid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_grid_obj.html">GridObj</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether a site is on a given grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>local i-index. </td></tr>
    <tr><td class="paramname">j</td><td>local j-index. </td></tr>
    <tr><td class="paramname">k</td><td>local k-index. </td></tr>
    <tr><td class="paramname">g</td><td>grid on which to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean answer. </dd></dl>

</div>
</div>
<a class="anchor" id="abfec29d90b6942de2f3c52c225a4d888"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GridUtils::isOnRecvLayer </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pos_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pos_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pos_z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether site is on an outer (receiver) halo. </p>
<p>Wrapper which checks every halo region of the rank for intersection with supplied site position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos_x</td><td>x-position of site. </td></tr>
    <tr><td class="paramname">pos_y</td><td>y-position of site. </td></tr>
    <tr><td class="paramname">pos_z</td><td>z-position of site. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean answer. </dd></dl>

</div>
</div>
<a class="anchor" id="a381a3ef0d42132313081b5c06f732092"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GridUtils::isOnRecvLayer </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>site_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_grid_utils_8h.html#a0cc91691e907a6a03b129d18a62fe33d">eCartMinMax</a>&#160;</td>
          <td class="paramname"><em>edge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether site is on an outer (receiver) halo. </p>
<p>Wrapper available which checks every halo. This method only checks the halo specified by the Cartesian direction and whether it is the left/bottom/front (minimum) or right/top/back (maximum) edge of the block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">site_position</td><td>position of site. </td></tr>
    <tr><td class="paramname">edge</td><td>combination of cartesian direction and choice of edge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean answer. </dd></dl>

</div>
</div>
<a class="anchor" id="af0692236725709af2d98872805fc84ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GridUtils::isOnSenderLayer </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pos_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pos_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pos_z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether site is on an inner (sender) halo. </p>
<p>Wrapper which checks every halo region of the rank for intersection with supplied site position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos_x</td><td>x-position of site. </td></tr>
    <tr><td class="paramname">pos_y</td><td>y-position of site. </td></tr>
    <tr><td class="paramname">pos_z</td><td>z-position of site. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean answer. </dd></dl>

</div>
</div>
<a class="anchor" id="a9179e27b25b1be249edd6d22455d57bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GridUtils::isOnSenderLayer </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>site_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_grid_utils_8h.html#a0cc91691e907a6a03b129d18a62fe33d">eCartMinMax</a>&#160;</td>
          <td class="paramname"><em>edge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether site is on an inner (sender) halo. </p>
<p>Wrapper available which checks every halo. This method only checks the halo specified by the Cartesian direction and whether it is the left/bottom/front (minimum) or right/top/back (maximum) edge of the block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">site_position</td><td>position of site. </td></tr>
    <tr><td class="paramname">edge</td><td>combination of cartesian direction and choice of edge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean answer. </dd></dl>

</div>
</div>
<a class="anchor" id="adcf9512bd143ac0b9ef7eec33f1510ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GridUtils::isOnThisRank </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_grid_utils_8h.html#a478f1e2cf9934de79a892e60980598dc">eLocationOnRank</a>&#160;</td>
          <td class="paramname"><em>loc</em> = <code><a class="el" href="_grid_utils_8h.html#a478f1e2cf9934de79a892e60980598dca6505acf15690a324459e652a94fc339a">eNone</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_grid_obj.html">GridObj</a> *&#160;</td>
          <td class="paramname"><em>grid</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>pos</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds out whether site with supplied position is on the current rank. </p>
<p>Will return true if the site is in the halo as well (send or recv). Location information provided to indicate where point is. Returns eNone enumeration if not request or if query is false. If a grid is supplied, will only return true if site is on the grid supplied. If you want to exclude the sites that belong to the halo you can call <a class="el" href="class_grid_utils.html#abfec29d90b6942de2f3c52c225a4d888" title="Check whether site is on an outer (receiver) halo. ">isOnRecvLayer()</a> or <a class="el" href="class_grid_utils.html#af0692236725709af2d98872805fc84ae" title="Check whether site is on an inner (sender) halo. ">isOnSenderLayer()</a> on the same site.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">x</td><td>x-position of site. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">y</td><td>y-position of site. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">z</td><td>z-position of site. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pos</td><td>pointer to the start of a vector in which local indices are returned. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">grid</td><td>grid being queried. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">loc</td><td>description of the location of the point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean answer. </dd></dl>

</div>
</div>
<a class="anchor" id="a4eca1ee0dff756b5cd65d45f84b24118"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GridUtils::isOnThisRank </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_grid_utils_8h.html#afbad8e4a2f1e9903755b1bd2fe8273cf">eCartesianDirection</a>&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_grid_utils_8h.html#a478f1e2cf9934de79a892e60980598dc">eLocationOnRank</a>&#160;</td>
          <td class="paramname"><em>loc</em> = <code><a class="el" href="_grid_utils_8h.html#a478f1e2cf9934de79a892e60980598dca6505acf15690a324459e652a94fc339a">eNone</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_grid_obj.html">GridObj</a> *&#160;</td>
          <td class="paramname"><em>grid</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pos</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds out whether the supplied position can be found on the current rank. </p>
<p>Direction-specific version of the overload.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">xyz</td><td>position (x, y or z) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dir</td><td>cartesian direction of interest (x, y or z). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">loc</td><td>description of the location of the point. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">grid</td><td>grid being queried. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pos</td><td>the local index of the found site. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean answer. </dd></dl>

</div>
</div>
<a class="anchor" id="a78d9c31d1c15198d1455627d1fa29804"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GridUtils::isOnTransitionLayer </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pos_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pos_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pos_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_grid_obj.html">GridObj</a> *&#160;</td>
          <td class="paramname"><em>grid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether site is on a TL. </p>
<p>Wrapper which checks every possible TL location on the grid supplied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos_x</td><td>x-position of site. </td></tr>
    <tr><td class="paramname">pos_y</td><td>y-position of site. </td></tr>
    <tr><td class="paramname">pos_z</td><td>z-position of site. </td></tr>
    <tr><td class="paramname">grid</td><td>given grid on which to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean answer. </dd></dl>

</div>
</div>
<a class="anchor" id="ae99e3fa97dcb3be1f6b88a55f232c2cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GridUtils::isOnTransitionLayer </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_grid_utils_8h.html#a0cc91691e907a6a03b129d18a62fe33d">eCartMinMax</a>&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_grid_obj.html">GridObj</a> *&#160;</td>
          <td class="paramname"><em>grid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether site is on a specific TL (to upper). </p>
<p>Wrapper available which checks every TL. This method only checks the TL specified by the Cartesian direction and whether it is the left/bottom/front (minimum) or right/top/back (maximum) edge of the supplied grid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>position of point. </td></tr>
    <tr><td class="paramname">edge</td><td>combination of cartesian direction and choice of edge. </td></tr>
    <tr><td class="paramname">grid</td><td>given grid on which to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean answer. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c13884020ab181ee8cb6dd2ea7e4fd7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GridUtils::isOverlapPeriodic </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_grid_obj.html">GridObj</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds out whether halo containng i,j,k links to neighbour rank periodically. </p>
<p>Checks the receiver layer containing local site i,j,k and determines from the MPI topology information whether this layer couples to an adjacent or periodic neighbour rank. I.e. if the neighbour is physically next to the rank or whether it is actaully at the other side of the domain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>local i-index of recv layer site being queried. </td></tr>
    <tr><td class="paramname">j</td><td>local j-index of recv layer site being queried. </td></tr>
    <tr><td class="paramname">k</td><td>local k-index of recv layer site being queried. </td></tr>
    <tr><td class="paramname">g</td><td>grid on which point being queried resides. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean answer. </dd></dl>

</div>
</div>
<a class="anchor" id="a2f172a6dd8b2749ca1c8336a64a07e29"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; GridUtils::linspace </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a linearly-spaced vector of values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>starting value of output vector. </td></tr>
    <tr><td class="paramname">max</td><td>ending point of output vector. </td></tr>
    <tr><td class="paramname">n</td><td>number of values in output vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector with n uniformly spaced values between min and max. </dd></dl>

</div>
</div>
<a class="anchor" id="a0051918813c63802d79bd7d172e8ad8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; GridUtils::matrix_multiply </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies matrix A by vector x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>a matrix represented as a vector or vectors. </td></tr>
    <tr><td class="paramname">x</td><td>a vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector which is A * x. </dd></dl>

</div>
</div>
<a class="anchor" id="a1f0d4a76be76a743c368c9a1d4d46cbc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; GridUtils::onespace </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a linearly-spaced vector of integers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>starting value of output vector. </td></tr>
    <tr><td class="paramname">max</td><td>ending point of output vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector with uniformly spaced integer values between min and max. </dd></dl>

</div>
</div>
<a class="anchor" id="aa3ca6e20ef4fa927cb845956d7565b1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void GridUtils::stridedCopy </td>
          <td>(</td>
          <td class="paramtype">NumType *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumType *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buf_offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a strided memcpy. </p>
<p>Memcpy() is designed to copy blocks of contiguous memory. Strided copy copies a pattern of contiguous blocks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>pointer to start of destination memory. </td></tr>
    <tr><td class="paramname">src</td><td>pointer to start of source memory. </td></tr>
    <tr><td class="paramname">block</td><td>size of contiguous block. </td></tr>
    <tr><td class="paramname">offset</td><td>offset from the start of the soruce array. </td></tr>
    <tr><td class="paramname">stride</td><td>number of elements between start of first block and start of second. </td></tr>
    <tr><td class="paramname">count</td><td>number of blocks in pattern </td></tr>
    <tr><td class="paramname">buf_offset</td><td>offset from start of destination buffer to start writing. Default is zero if not supplied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6f5af65d6bb25e0d34be50670b41514f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; GridUtils::subtract </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts two vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>a vector. </td></tr>
    <tr><td class="paramname">b</td><td>a second vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector which is a - b. </dd></dl>

</div>
</div>
<a class="anchor" id="a5a3e26a94e62833f0a9e5a4bda066dac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static NumType GridUtils::upToZero </td>
          <td>(</td>
          <td class="paramtype">NumType&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds a negative value up to zero. </p>
<p>If value is positive, return the value unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>value to be rounded </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NumType rounded value </dd></dl>

</div>
</div>
<a class="anchor" id="a01eba1d90d3414637d5031850ad89ce3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; GridUtils::vecmultiply </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies a scalar by a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>a scalar double. </td></tr>
    <tr><td class="paramname">vec</td><td>a vector double. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector which is a scalar multiplied by a vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a1e0d0da69ec1543835b98bca884f8927"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double GridUtils::vecnorm </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vec</em>[L_DIMS]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the L2 norm using the vector supplied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>old-style C array representing a vector with the same number of number of components as the problem dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the L2 norm. </dd></dl>

</div>
</div>
<a class="anchor" id="ae7d797edf50b3c3a448d59684a135aee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double GridUtils::vecnorm </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the L2 norm using the vector components supplied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>first vector component. </td></tr>
    <tr><td class="paramname">val2</td><td>second vector component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the L2 norm. </dd></dl>

</div>
</div>
<a class="anchor" id="a6caced99b15b01746c1fb5828c447034"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double GridUtils::vecnorm </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the L2 norm using the vector components supplied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>first vector component. </td></tr>
    <tr><td class="paramname">val2</td><td>second vector component. </td></tr>
    <tr><td class="paramname">val3</td><td>third vector component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the L2 norm. </dd></dl>

</div>
</div>
<a class="anchor" id="a45167f9bde2e34d868a4ccc64f588ab2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double GridUtils::vecnorm </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the L2 norm using the vector supplied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>C++ std::vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the L2 norm. </dd></dl>

</div>
</div>
<a class="anchor" id="a78aa4876d7066bce253c52457e7b901d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static NumType GridUtils::vecnorm </td>
          <td>(</td>
          <td class="paramtype">NumType&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumType&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumType&#160;</td>
          <td class="paramname"><em>a3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the L2-norm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a1</td><td>first component of the vector </td></tr>
    <tr><td class="paramname">a2</td><td>second component of the vector </td></tr>
    <tr><td class="paramname">a3</td><td>third component of the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NumType scalar quantity </dd></dl>

</div>
</div>
<a class="anchor" id="a7a169fc043a585f20936b314def45fe7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static NumType GridUtils::vecnorm </td>
          <td>(</td>
          <td class="paramtype">NumType&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumType&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the L2-norm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a1</td><td>first component of the vector </td></tr>
    <tr><td class="paramname">a2</td><td>second component of the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NumType scalar quantity </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ae2b566735d973bc25f1a6416010efa70"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int GridUtils::dir_reflect</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= </div><div class="line">    {</div><div class="line">        {1, 0, 2, 3, 4, 5, 9, 8, 7, 6, 10, 11, 12, 13, 16, 17, 14, 15, 18}, </div><div class="line">        {1, 0, 2, 3, 4, 5, 9, 8, 7, 6, 10, 11, 12, 13, 16, 17, 14, 15, 18},</div><div class="line">        {0, 1, 3, 2, 4, 5, 8, 9, 6, 7, 13, 12, 11, 10, 14, 15, 16, 17, 18},</div><div class="line">        {0, 1, 3, 2, 4, 5, 8, 9, 6, 7, 13, 12, 11, 10, 14, 15, 16, 17, 18},</div><div class="line">        {0, 1, 2, 3, 5, 4, 6, 7, 8, 9, 12, 13, 10, 11, 17, 16, 15, 14, 18},</div><div class="line">        {0, 1, 2, 3, 5, 4, 6, 7, 8, 9, 12, 13, 10, 11, 17, 16, 15, 14, 18}</div><div class="line">    }</div></div><!-- fragment -->
<p>Array with hardcoded direction numbering for specular reflection. </p>

</div>
</div>
<a class="anchor" id="a298239096e929c1ba4eba925e351c1b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ofstream * GridUtils::logfile</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle to output file. </p>

</div>
</div>
<a class="anchor" id="a9b58748e9e05e84852962d7abc7942e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string GridUtils::path_str</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static string representing output path. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_grid_utils_8h_source.html">GridUtils.h</a></li>
<li><a class="el" href="_grid_obj_8cpp.html">GridObj.cpp</a></li>
<li><a class="el" href="_grid_utils_8cpp.html">GridUtils.cpp</a></li>
<li><a class="el" href="main__lbm_8cpp.html">main_lbm.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
