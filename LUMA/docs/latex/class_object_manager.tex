\hypertarget{class_object_manager}{}\section{Object\+Manager Class Reference}
\label{class_object_manager}\index{Object\+Manager@{Object\+Manager}}


Object Manager class.  




{\ttfamily \#include $<$Object\+Manager.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{class_object_manager_a2ec2df889c396d94d2fe1807c10847bb}{ibm\+\_\+apply} ()
\begin{DoxyCompactList}\small\item\em Perform I\+BM procedure. \end{DoxyCompactList}\item 
void \hyperlink{class_object_manager_af89336910b6f3157e5b17b4ea6d30a12}{ibm\+\_\+build\+\_\+body} (int body\+\_\+type)
\begin{DoxyCompactList}\small\item\em Builds a prefab immersed boundary body. \end{DoxyCompactList}\item 
void \hyperlink{class_object_manager_ac8270fe5b646e512a34748b5ca51671c}{ibm\+\_\+build\+\_\+body} (\hyperlink{class_p_cpts}{P\+Cpts} $\ast$\+\_\+\+P\+Cpts, \hyperlink{class_grid_obj}{Grid\+Obj} $\ast$owner)
\begin{DoxyCompactList}\small\item\em Wrapper for building a body from a point cloud. \end{DoxyCompactList}\item 
void \hyperlink{class_object_manager_aa4e5e286a6fe1d9fcaf393ffed329250}{ibm\+\_\+initialise} ()
\begin{DoxyCompactList}\small\item\em Initialise the array of i\+Bodies. \end{DoxyCompactList}\item 
double \hyperlink{class_object_manager_a4e55e3a84bae37a75f8487fd575169fb}{ibm\+\_\+deltakernel} (double rad, double dilation)
\begin{DoxyCompactList}\small\item\em Method to evaluate delta kernel at supplied location. \end{DoxyCompactList}\item 
void \hyperlink{class_object_manager_aff31915ad0effdcc8dc18f602ddd1c20}{ibm\+\_\+interpol} (int ib)
\begin{DoxyCompactList}\small\item\em Interpolate velocity field onto markers. \end{DoxyCompactList}\item 
void \hyperlink{class_object_manager_a8096f9ec97cf7ce2fc45ebfcbdf3617e}{ibm\+\_\+spread} (int ib)
\begin{DoxyCompactList}\small\item\em Spread restorative force back onto marker support. \end{DoxyCompactList}\item 
void \hyperlink{class_object_manager_a500427b7ac8fc16eac33f804f64abdab}{ibm\+\_\+findsupport} (int ib, int m)
\begin{DoxyCompactList}\small\item\em Finds support points for i\+Body. \end{DoxyCompactList}\item 
void \hyperlink{class_object_manager_a5722d37636b6cd2ab92efdb6fe4bcdfa}{ibm\+\_\+computeforce} (int ib)
\begin{DoxyCompactList}\small\item\em Compute restorative force at each marker in a body. \end{DoxyCompactList}\item 
double \hyperlink{class_object_manager_a2b544fe34e298302f3e5e8b2f981c2d8}{ibm\+\_\+findepsilon} (int ib)
\begin{DoxyCompactList}\small\item\em Compute epsilon for a given i\+Body. \end{DoxyCompactList}\item 
void \hyperlink{class_object_manager_ad874ba69d231d4c1720c4e3a68ff3499}{ibm\+\_\+move\+\_\+bodies} ()
\begin{DoxyCompactList}\small\item\em Moves i\+Bodies after applying I\+BM. \end{DoxyCompactList}\item 
double \hyperlink{class_object_manager_adad4317bfbe5bae833c4ffa3e4538d92}{ibm\+\_\+bicgstab} (std\+::vector$<$ std\+::vector$<$ double $>$ $>$ \&Amatrix, std\+::vector$<$ double $>$ \&b\+Vector, std\+::vector$<$ double $>$ \&epsilon, double tolerance, int maxiterations)
\begin{DoxyCompactList}\small\item\em Biconjugate gradient method. \end{DoxyCompactList}\item 
void \hyperlink{class_object_manager_a956c12cba071c6b8844371c03433f82c}{ibm\+\_\+jacowire} (int ib)
\begin{DoxyCompactList}\small\item\em Structural calculation of flexible cilia. \end{DoxyCompactList}\item 
void \hyperlink{class_object_manager_a53eedab20e69a10ae861197b614751db}{ibm\+\_\+position\+\_\+update} (int ib)
\begin{DoxyCompactList}\small\item\em Update the position of a deformable i\+Body. \end{DoxyCompactList}\item 
void \hyperlink{class_object_manager_ae8f08e2935c8999db99b41a3c97b63c5}{ibm\+\_\+position\+\_\+update\+\_\+grp} (int group)
\begin{DoxyCompactList}\small\item\em Update the position of a group of deformable i\+Bodies. \end{DoxyCompactList}\item 
void \hyperlink{class_object_manager_a7bf970976700f9949bb08d8dc7f8e637}{ibm\+\_\+banbks} (double $\ast$$\ast$a, long n, int m1, int m2, double $\ast$$\ast$al, unsigned long indx\mbox{[}$\,$\mbox{]}, double b\mbox{[}$\,$\mbox{]})
\begin{DoxyCompactList}\small\item\em Solution of a banded diagonal linear system. \end{DoxyCompactList}\item 
void \hyperlink{class_object_manager_a77eb5ec758b5956e0a609fa1fba2f8e8}{ibm\+\_\+bandec} (double $\ast$$\ast$a, long n, int m1, int m2, double $\ast$$\ast$al, unsigned long indx\mbox{[}$\,$\mbox{]}, double $\ast$d)
\begin{DoxyCompactList}\small\item\em LU decomposition of band diagonal matrix. \end{DoxyCompactList}\item 
void \hyperlink{class_object_manager_a099a446ac7f045d11d6be6babd0a31ab}{bfl\+\_\+build\+\_\+body} (int body\+\_\+type)
\begin{DoxyCompactList}\small\item\em Prefab body building routine. \end{DoxyCompactList}\item 
void \hyperlink{class_object_manager_a56c65bd5122aa7e7026fb8d2315482f3}{bfl\+\_\+build\+\_\+body} (\hyperlink{class_p_cpts}{P\+Cpts} $\ast$\+\_\+\+P\+Cpts)
\begin{DoxyCompactList}\small\item\em Wrapper for building B\+FL body from point cloud. \end{DoxyCompactList}\item 
void \hyperlink{class_object_manager_a6a35b34d77e7cd56060a6953d0d0860a}{compute\+Lift\+Drag} (int i, int j, int k, \hyperlink{class_grid_obj}{Grid\+Obj} $\ast$g)
\begin{DoxyCompactList}\small\item\em Compute forces on a rigid object. \end{DoxyCompactList}\item 
void \hyperlink{class_object_manager_a39aa351c7b338473be4871111da5c5bd}{io\+\_\+vtk\+\_\+\+I\+Bwriter} (double tval)
\begin{DoxyCompactList}\small\item\em Write IB body data to V\+TK file. \end{DoxyCompactList}\item 
void \hyperlink{class_object_manager_a1f9a40c58bdb3bd9797f7c44864835ec}{io\+\_\+write\+\_\+body\+\_\+pos} (int timestep)
\begin{DoxyCompactList}\small\item\em Write out position of immersed boundary bodies. \end{DoxyCompactList}\item 
void \hyperlink{class_object_manager_ab46e89c9eaf8ca1c9ec264545f39cd7f}{io\+\_\+write\+\_\+lift\+\_\+drag} (int timestep)
\begin{DoxyCompactList}\small\item\em Write out forces on the markers of immersed boundary bodies. \end{DoxyCompactList}\item 
void \hyperlink{class_object_manager_aaa1b7e2a3392c2a8d85606041b986b4d}{io\+\_\+restart} (bool I\+O\+\_\+flag, int level)
\begin{DoxyCompactList}\small\item\em Read/write IB body information to restart file. \end{DoxyCompactList}\item 
void \hyperlink{class_object_manager_a5c11d747c3df9e91d5fc2dac836d7b7e}{io\+\_\+read\+In\+Cloud} (\hyperlink{class_p_cpts}{P\+Cpts} $\ast$\+\_\+\+P\+Cpts, \hyperlink{_object_manager_8h_a7b78fa3db30dfb9c1efc82bf886fe184}{e\+Object\+Type} objtype)
\begin{DoxyCompactList}\small\item\em Read in point cloud data. \end{DoxyCompactList}\item 
void \hyperlink{class_object_manager_adf65260d81584613fa33f2e7658f1b36}{io\+\_\+write\+Force\+On\+Object} (double tval)
\begin{DoxyCompactList}\small\item\em Write out the forces on a solid object. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{class_object_manager}{Object\+Manager} $\ast$ \hyperlink{class_object_manager_acf7a2f12f034c76d9e3a5aa5837dddb5}{get\+Instance} ()
\begin{DoxyCompactList}\small\item\em Get instance method. \end{DoxyCompactList}\item 
static void \hyperlink{class_object_manager_a5945decc43eb5fdeaaad101fa7aa282f}{destroy\+Instance} ()
\begin{DoxyCompactList}\small\item\em Destroy instance method. \end{DoxyCompactList}\item 
static \hyperlink{class_object_manager}{Object\+Manager} $\ast$ \hyperlink{class_object_manager_a3c648f3d7388df47db0db9fcb4b8b618}{get\+Instance} (\hyperlink{class_grid_obj}{Grid\+Obj} $\ast$g)
\begin{DoxyCompactList}\small\item\em Overloaded get instance passing in pointer to grid hierarchy. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{class_object_manager_a55cfec1721fb1b9d9e7592bd6288c998}{Grid\+Obj}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Object Manager class. 

Class to manage all objects in the domain from creation through manipulation to destruction. 

\subsection{Member Function Documentation}
\index{Object\+Manager@{Object\+Manager}!bfl\+\_\+build\+\_\+body@{bfl\+\_\+build\+\_\+body}}
\index{bfl\+\_\+build\+\_\+body@{bfl\+\_\+build\+\_\+body}!Object\+Manager@{Object\+Manager}}
\subsubsection[{\texorpdfstring{bfl\+\_\+build\+\_\+body(int body\+\_\+type)}{bfl_build_body(int body_type)}}]{\setlength{\rightskip}{0pt plus 5cm}void Object\+Manager\+::bfl\+\_\+build\+\_\+body (
\begin{DoxyParamCaption}
\item[{int}]{body\+\_\+type}
\end{DoxyParamCaption}
)}\hypertarget{class_object_manager_a099a446ac7f045d11d6be6babd0a31ab}{}\label{class_object_manager_a099a446ac7f045d11d6be6babd0a31ab}


Prefab body building routine. 

Not implemented in this version.


\begin{DoxyParams}{Parameters}
{\em body\+\_\+type} & type of prefab body to be built. \\
\hline
\end{DoxyParams}
\index{Object\+Manager@{Object\+Manager}!bfl\+\_\+build\+\_\+body@{bfl\+\_\+build\+\_\+body}}
\index{bfl\+\_\+build\+\_\+body@{bfl\+\_\+build\+\_\+body}!Object\+Manager@{Object\+Manager}}
\subsubsection[{\texorpdfstring{bfl\+\_\+build\+\_\+body(\+P\+Cpts $\ast$\+\_\+\+P\+Cpts)}{bfl_build_body(PCpts *_PCpts)}}]{\setlength{\rightskip}{0pt plus 5cm}void Object\+Manager\+::bfl\+\_\+build\+\_\+body (
\begin{DoxyParamCaption}
\item[{{\bf P\+Cpts} $\ast$}]{\+\_\+\+P\+Cpts}
\end{DoxyParamCaption}
)}\hypertarget{class_object_manager_a56c65bd5122aa7e7026fb8d2315482f3}{}\label{class_object_manager_a56c65bd5122aa7e7026fb8d2315482f3}


Wrapper for building B\+FL body from point cloud. 


\begin{DoxyParams}{Parameters}
{\em \+\_\+\+P\+Cpts} & pointer to point cloud data. \\
\hline
\end{DoxyParams}
\index{Object\+Manager@{Object\+Manager}!compute\+Lift\+Drag@{compute\+Lift\+Drag}}
\index{compute\+Lift\+Drag@{compute\+Lift\+Drag}!Object\+Manager@{Object\+Manager}}
\subsubsection[{\texorpdfstring{compute\+Lift\+Drag(int i, int j, int k, Grid\+Obj $\ast$g)}{computeLiftDrag(int i, int j, int k, GridObj *g)}}]{\setlength{\rightskip}{0pt plus 5cm}void Object\+Manager\+::compute\+Lift\+Drag (
\begin{DoxyParamCaption}
\item[{int}]{i, }
\item[{int}]{j, }
\item[{int}]{k, }
\item[{{\bf Grid\+Obj} $\ast$}]{g}
\end{DoxyParamCaption}
)}\hypertarget{class_object_manager_a6a35b34d77e7cd56060a6953d0d0860a}{}\label{class_object_manager_a6a35b34d77e7cd56060a6953d0d0860a}


Compute forces on a rigid object. 

Uses momentum exchange to compute forces on rigid bodies. Currently working with bounce-\/back objects only. There is no bounding box so if we have walls in the domain they will be counted as well. Also only possible to differentiate between bodies. Lumps all bodies together.\+identify which body this site relates to so we can differentiate.


\begin{DoxyParams}{Parameters}
{\em i} & local i-\/index of solid site. \\
\hline
{\em j} & local j-\/index of solid site. \\
\hline
{\em k} & local k-\/index of solid site. \\
\hline
{\em g} & pointer to grid on which object resides. \\
\hline
\end{DoxyParams}
\index{Object\+Manager@{Object\+Manager}!destroy\+Instance@{destroy\+Instance}}
\index{destroy\+Instance@{destroy\+Instance}!Object\+Manager@{Object\+Manager}}
\subsubsection[{\texorpdfstring{destroy\+Instance()}{destroyInstance()}}]{\setlength{\rightskip}{0pt plus 5cm}void Object\+Manager\+::destroy\+Instance (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_object_manager_a5945decc43eb5fdeaaad101fa7aa282f}{}\label{class_object_manager_a5945decc43eb5fdeaaad101fa7aa282f}


Destroy instance method. 

Instance destuctor. \index{Object\+Manager@{Object\+Manager}!get\+Instance@{get\+Instance}}
\index{get\+Instance@{get\+Instance}!Object\+Manager@{Object\+Manager}}
\subsubsection[{\texorpdfstring{get\+Instance()}{getInstance()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Object\+Manager} $\ast$ Object\+Manager\+::get\+Instance (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_object_manager_acf7a2f12f034c76d9e3a5aa5837dddb5}{}\label{class_object_manager_acf7a2f12f034c76d9e3a5aa5837dddb5}


Get instance method. 

Instance creator. \index{Object\+Manager@{Object\+Manager}!get\+Instance@{get\+Instance}}
\index{get\+Instance@{get\+Instance}!Object\+Manager@{Object\+Manager}}
\subsubsection[{\texorpdfstring{get\+Instance(\+Grid\+Obj $\ast$g)}{getInstance(GridObj *g)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Object\+Manager} $\ast$ Object\+Manager\+::get\+Instance (
\begin{DoxyParamCaption}
\item[{{\bf Grid\+Obj} $\ast$}]{g}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_object_manager_a3c648f3d7388df47db0db9fcb4b8b618}{}\label{class_object_manager_a3c648f3d7388df47db0db9fcb4b8b618}


Overloaded get instance passing in pointer to grid hierarchy. 

Instance creator with grid hierarchy assignment.


\begin{DoxyParams}{Parameters}
{\em g} & pointer to grid hierarchy. \\
\hline
\end{DoxyParams}
\index{Object\+Manager@{Object\+Manager}!ibm\+\_\+apply@{ibm\+\_\+apply}}
\index{ibm\+\_\+apply@{ibm\+\_\+apply}!Object\+Manager@{Object\+Manager}}
\subsubsection[{\texorpdfstring{ibm\+\_\+apply()}{ibm_apply()}}]{\setlength{\rightskip}{0pt plus 5cm}void Object\+Manager\+::ibm\+\_\+apply (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_object_manager_a2ec2df889c396d94d2fe1807c10847bb}{}\label{class_object_manager_a2ec2df889c396d94d2fe1807c10847bb}


Perform I\+BM procedure. 

\index{Object\+Manager@{Object\+Manager}!ibm\+\_\+banbks@{ibm\+\_\+banbks}}
\index{ibm\+\_\+banbks@{ibm\+\_\+banbks}!Object\+Manager@{Object\+Manager}}
\subsubsection[{\texorpdfstring{ibm\+\_\+banbks(double $\ast$$\ast$a, long n, int m1, int m2, double $\ast$$\ast$al, unsigned long indx[], double b[])}{ibm_banbks(double **a, long n, int m1, int m2, double **al, unsigned long indx[], double b[])}}]{\setlength{\rightskip}{0pt plus 5cm}void Object\+Manager\+::ibm\+\_\+banbks (
\begin{DoxyParamCaption}
\item[{double $\ast$$\ast$}]{a, }
\item[{long}]{n, }
\item[{int}]{m1, }
\item[{int}]{m2, }
\item[{double $\ast$$\ast$}]{al, }
\item[{unsigned long}]{indx\mbox{[}$\,$\mbox{]}, }
\item[{double}]{b\mbox{[}$\,$\mbox{]}}
\end{DoxyParamCaption}
)}\hypertarget{class_object_manager_a7bf970976700f9949bb08d8dc7f8e637}{}\label{class_object_manager_a7bf970976700f9949bb08d8dc7f8e637}


Solution of a banded diagonal linear system. 

Given the arrays A, AL, and I\+N\+DX as returned from \hyperlink{class_object_manager_a77eb5ec758b5956e0a609fa1fba2f8e8}{ibm\+\_\+bandec()}, and given a right-\/hand side vector B\mbox{[}1..n\mbox{]}, solves the band diagonal linear equations AX = B. The solution vector X overwrites B. The other input arrays are not modified, and can be left in place for successive calls with different right-\/hand sides. (C) Copr. 1986-\/92 Numerical Recipes Software ?421.\+1-\/9.


\begin{DoxyParams}{Parameters}
{\em a} & array of subdiagonal and superdiagonals rows \\
\hline
{\em n} & size of the square matrix A \\
\hline
{\em m1} & number of subdiagonal rows \\
\hline
{\em m2} & number of superdiagonal rows \\
\hline
{\em al} & lower triangular matrix \\
\hline
{\em indx} & row permutation vector \\
\hline
{\em b} & right hand side vector \\
\hline
\end{DoxyParams}
\index{Object\+Manager@{Object\+Manager}!ibm\+\_\+bandec@{ibm\+\_\+bandec}}
\index{ibm\+\_\+bandec@{ibm\+\_\+bandec}!Object\+Manager@{Object\+Manager}}
\subsubsection[{\texorpdfstring{ibm\+\_\+bandec(double $\ast$$\ast$a, long n, int m1, int m2, double $\ast$$\ast$al, unsigned long indx[], double $\ast$d)}{ibm_bandec(double **a, long n, int m1, int m2, double **al, unsigned long indx[], double *d)}}]{\setlength{\rightskip}{0pt plus 5cm}void Object\+Manager\+::ibm\+\_\+bandec (
\begin{DoxyParamCaption}
\item[{double $\ast$$\ast$}]{a, }
\item[{long}]{n, }
\item[{int}]{m1, }
\item[{int}]{m2, }
\item[{double $\ast$$\ast$}]{al, }
\item[{unsigned long}]{indx\mbox{[}$\,$\mbox{]}, }
\item[{double $\ast$}]{d}
\end{DoxyParamCaption}
)}\hypertarget{class_object_manager_a77eb5ec758b5956e0a609fa1fba2f8e8}{}\label{class_object_manager_a77eb5ec758b5956e0a609fa1fba2f8e8}


LU decomposition of band diagonal matrix. 

Given an n by n band diagonal matrix A with m1 subdiagonal rows and m2 superdiagonal rows, compactly stored in the array A\mbox{[}1..n\mbox{]}\mbox{[}1..m1+m2+1\mbox{]} , this routine constructs an LU decomposition of a rowwise permutation of A. The upper triangular matrix replaces A, while the lower triangular matrix is returned in AL\mbox{[}1..n\mbox{]}\mbox{[}1..m1\mbox{]}. I\+N\+DX\mbox{[}1..n\mbox{]} is an output vector which records the row permutation effected by the partial pivoting; D is output as +/-\/1 depending on whether the number of row interchanges was even or odd, respectively. This routine is used in combination with \hyperlink{class_object_manager_a7bf970976700f9949bb08d8dc7f8e637}{ibm\+\_\+banbks()} to solve band-\/diagonal sets of equations. Once the matrix A has been decomposed, any number of right-\/hand sides can be solved in turn by repeated calls to \hyperlink{class_object_manager_a7bf970976700f9949bb08d8dc7f8e637}{ibm\+\_\+banbks()}. (C) Copr. 1986-\/92 Numerical Recipes Software ?421.\+1-\/9.


\begin{DoxyParams}{Parameters}
{\em a} & array of subdiagonal and superdiagonals rows \\
\hline
{\em n} & size of the square matrix A \\
\hline
{\em m1} & number of subdiagonal rows \\
\hline
{\em m2} & number of superdiagonal rows \\
\hline
{\em al} & lower triangular matrix \\
\hline
{\em indx} & row permutation vector \\
\hline
{\em d} & odd or even number of row interchages \\
\hline
\end{DoxyParams}
\index{Object\+Manager@{Object\+Manager}!ibm\+\_\+bicgstab@{ibm\+\_\+bicgstab}}
\index{ibm\+\_\+bicgstab@{ibm\+\_\+bicgstab}!Object\+Manager@{Object\+Manager}}
\subsubsection[{\texorpdfstring{ibm\+\_\+bicgstab(std\+::vector$<$ std\+::vector$<$ double $>$ $>$ \&\+Amatrix, std\+::vector$<$ double $>$ \&b\+Vector, std\+::vector$<$ double $>$ \&epsilon, double tolerance, int maxiterations)}{ibm_bicgstab(std::vector< std::vector< double > > &Amatrix, std::vector< double > &bVector, std::vector< double > &epsilon, double tolerance, int maxiterations)}}]{\setlength{\rightskip}{0pt plus 5cm}double Object\+Manager\+::ibm\+\_\+bicgstab (
\begin{DoxyParamCaption}
\item[{std\+::vector$<$ std\+::vector$<$ double $>$ $>$ \&}]{Amatrix, }
\item[{std\+::vector$<$ double $>$ \&}]{b\+Vector, }
\item[{std\+::vector$<$ double $>$ \&}]{epsilon, }
\item[{double}]{tolerance, }
\item[{int}]{maxiterations}
\end{DoxyParamCaption}
)}\hypertarget{class_object_manager_adad4317bfbe5bae833c4ffa3e4538d92}{}\label{class_object_manager_adad4317bfbe5bae833c4ffa3e4538d92}


Biconjugate gradient method. 

Biconjugate gradient stabilised method of solving a linear system Ax = b. Solution is performed iteratively.


\begin{DoxyParams}{Parameters}
{\em Amatrix} & the A matrix in the linear system. \\
\hline
{\em b\+Vector} & the b vector in the linear system. \\
\hline
{\em epsilon} & epsilon paramters for each marker. \\
\hline
{\em tolerance} & tolerance of solution. \\
\hline
{\em maxiterations} & maximum number of iterations. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the minimum residual achieved by the solver. 
\end{DoxyReturn}
\index{Object\+Manager@{Object\+Manager}!ibm\+\_\+build\+\_\+body@{ibm\+\_\+build\+\_\+body}}
\index{ibm\+\_\+build\+\_\+body@{ibm\+\_\+build\+\_\+body}!Object\+Manager@{Object\+Manager}}
\subsubsection[{\texorpdfstring{ibm\+\_\+build\+\_\+body(int body\+\_\+type)}{ibm_build_body(int body_type)}}]{\setlength{\rightskip}{0pt plus 5cm}void Object\+Manager\+::ibm\+\_\+build\+\_\+body (
\begin{DoxyParamCaption}
\item[{int}]{body\+\_\+type}
\end{DoxyParamCaption}
)}\hypertarget{class_object_manager_af89336910b6f3157e5b17b4ea6d30a12}{}\label{class_object_manager_af89336910b6f3157e5b17b4ea6d30a12}


Builds a prefab immersed boundary body. 


\begin{DoxyParams}{Parameters}
{\em body\+\_\+type} & type of body to be built. \\
\hline
\end{DoxyParams}
\index{Object\+Manager@{Object\+Manager}!ibm\+\_\+build\+\_\+body@{ibm\+\_\+build\+\_\+body}}
\index{ibm\+\_\+build\+\_\+body@{ibm\+\_\+build\+\_\+body}!Object\+Manager@{Object\+Manager}}
\subsubsection[{\texorpdfstring{ibm\+\_\+build\+\_\+body(\+P\+Cpts $\ast$\+\_\+\+P\+Cpts, Grid\+Obj $\ast$owner)}{ibm_build_body(PCpts *_PCpts, GridObj *owner)}}]{\setlength{\rightskip}{0pt plus 5cm}void Object\+Manager\+::ibm\+\_\+build\+\_\+body (
\begin{DoxyParamCaption}
\item[{{\bf P\+Cpts} $\ast$}]{\+\_\+\+P\+Cpts, }
\item[{{\bf Grid\+Obj} $\ast$}]{owner}
\end{DoxyParamCaption}
)}\hypertarget{class_object_manager_ac8270fe5b646e512a34748b5ca51671c}{}\label{class_object_manager_ac8270fe5b646e512a34748b5ca51671c}


Wrapper for building a body from a point cloud. 


\begin{DoxyParams}{Parameters}
{\em \+\_\+\+P\+Cpts} & pointer to point cloud data. \\
\hline
{\em owner} & pointer to the grid on which the body is to be placed. \\
\hline
\end{DoxyParams}
\index{Object\+Manager@{Object\+Manager}!ibm\+\_\+computeforce@{ibm\+\_\+computeforce}}
\index{ibm\+\_\+computeforce@{ibm\+\_\+computeforce}!Object\+Manager@{Object\+Manager}}
\subsubsection[{\texorpdfstring{ibm\+\_\+computeforce(int ib)}{ibm_computeforce(int ib)}}]{\setlength{\rightskip}{0pt plus 5cm}void Object\+Manager\+::ibm\+\_\+computeforce (
\begin{DoxyParamCaption}
\item[{int}]{ib}
\end{DoxyParamCaption}
)}\hypertarget{class_object_manager_a5722d37636b6cd2ab92efdb6fe4bcdfa}{}\label{class_object_manager_a5722d37636b6cd2ab92efdb6fe4bcdfa}


Compute restorative force at each marker in a body. 


\begin{DoxyParams}{Parameters}
{\em ib} & i\+Body being operated on. \\
\hline
\end{DoxyParams}
\index{Object\+Manager@{Object\+Manager}!ibm\+\_\+deltakernel@{ibm\+\_\+deltakernel}}
\index{ibm\+\_\+deltakernel@{ibm\+\_\+deltakernel}!Object\+Manager@{Object\+Manager}}
\subsubsection[{\texorpdfstring{ibm\+\_\+deltakernel(double rad, double dilation)}{ibm_deltakernel(double rad, double dilation)}}]{\setlength{\rightskip}{0pt plus 5cm}double Object\+Manager\+::ibm\+\_\+deltakernel (
\begin{DoxyParamCaption}
\item[{double}]{radius, }
\item[{double}]{dilation}
\end{DoxyParamCaption}
)}\hypertarget{class_object_manager_a4e55e3a84bae37a75f8487fd575169fb}{}\label{class_object_manager_a4e55e3a84bae37a75f8487fd575169fb}


Method to evaluate delta kernel at supplied location. 

Radius and dilation must be in the same units.


\begin{DoxyParams}{Parameters}
{\em radius} & location at which kernel should be evaluated. \\
\hline
{\em dilation} & width of kernel function. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
value of kernel function. 
\end{DoxyReturn}
\index{Object\+Manager@{Object\+Manager}!ibm\+\_\+findepsilon@{ibm\+\_\+findepsilon}}
\index{ibm\+\_\+findepsilon@{ibm\+\_\+findepsilon}!Object\+Manager@{Object\+Manager}}
\subsubsection[{\texorpdfstring{ibm\+\_\+findepsilon(int ib)}{ibm_findepsilon(int ib)}}]{\setlength{\rightskip}{0pt plus 5cm}double Object\+Manager\+::ibm\+\_\+findepsilon (
\begin{DoxyParamCaption}
\item[{int}]{ib}
\end{DoxyParamCaption}
)}\hypertarget{class_object_manager_a2b544fe34e298302f3e5e8b2f981c2d8}{}\label{class_object_manager_a2b544fe34e298302f3e5e8b2f981c2d8}


Compute epsilon for a given i\+Body. 


\begin{DoxyParams}{Parameters}
{\em ib} & i\+Body being operated on. \\
\hline
\end{DoxyParams}
\index{Object\+Manager@{Object\+Manager}!ibm\+\_\+findsupport@{ibm\+\_\+findsupport}}
\index{ibm\+\_\+findsupport@{ibm\+\_\+findsupport}!Object\+Manager@{Object\+Manager}}
\subsubsection[{\texorpdfstring{ibm\+\_\+findsupport(int ib, int m)}{ibm_findsupport(int ib, int m)}}]{\setlength{\rightskip}{0pt plus 5cm}void Object\+Manager\+::ibm\+\_\+findsupport (
\begin{DoxyParamCaption}
\item[{int}]{ib, }
\item[{int}]{m}
\end{DoxyParamCaption}
)}\hypertarget{class_object_manager_a500427b7ac8fc16eac33f804f64abdab}{}\label{class_object_manager_a500427b7ac8fc16eac33f804f64abdab}


Finds support points for i\+Body. 

Support for given marker in given body is sought on the owning grid.


\begin{DoxyParams}{Parameters}
{\em ib} & body under consideration. \\
\hline
{\em m} & marker whose support is to be found. \\
\hline
\end{DoxyParams}
\index{Object\+Manager@{Object\+Manager}!ibm\+\_\+initialise@{ibm\+\_\+initialise}}
\index{ibm\+\_\+initialise@{ibm\+\_\+initialise}!Object\+Manager@{Object\+Manager}}
\subsubsection[{\texorpdfstring{ibm\+\_\+initialise()}{ibm_initialise()}}]{\setlength{\rightskip}{0pt plus 5cm}void Object\+Manager\+::ibm\+\_\+initialise (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_object_manager_aa4e5e286a6fe1d9fcaf393ffed329250}{}\label{class_object_manager_aa4e5e286a6fe1d9fcaf393ffed329250}


Initialise the array of i\+Bodies. 

Computes support and epsilon values. \index{Object\+Manager@{Object\+Manager}!ibm\+\_\+interpol@{ibm\+\_\+interpol}}
\index{ibm\+\_\+interpol@{ibm\+\_\+interpol}!Object\+Manager@{Object\+Manager}}
\subsubsection[{\texorpdfstring{ibm\+\_\+interpol(int ib)}{ibm_interpol(int ib)}}]{\setlength{\rightskip}{0pt plus 5cm}void Object\+Manager\+::ibm\+\_\+interpol (
\begin{DoxyParamCaption}
\item[{int}]{ib}
\end{DoxyParamCaption}
)}\hypertarget{class_object_manager_aff31915ad0effdcc8dc18f602ddd1c20}{}\label{class_object_manager_aff31915ad0effdcc8dc18f602ddd1c20}


Interpolate velocity field onto markers. 


\begin{DoxyParams}{Parameters}
{\em ib} & i\+Body being operated on. \\
\hline
\end{DoxyParams}
\index{Object\+Manager@{Object\+Manager}!ibm\+\_\+jacowire@{ibm\+\_\+jacowire}}
\index{ibm\+\_\+jacowire@{ibm\+\_\+jacowire}!Object\+Manager@{Object\+Manager}}
\subsubsection[{\texorpdfstring{ibm\+\_\+jacowire(int ib)}{ibm_jacowire(int ib)}}]{\setlength{\rightskip}{0pt plus 5cm}void Object\+Manager\+::ibm\+\_\+jacowire (
\begin{DoxyParamCaption}
\item[{int}]{ib}
\end{DoxyParamCaption}
)}\hypertarget{class_object_manager_a956c12cba071c6b8844371c03433f82c}{}\label{class_object_manager_a956c12cba071c6b8844371c03433f82c}


Structural calculation of flexible cilia. 

Models the structural behaviour of a thin wire using Euler-\/\+Bernoulli beam elements. Only implemented for one simply supported end and one free end at present.


\begin{DoxyParams}{Parameters}
{\em ib} & index of body to which calculation is to be applied. \\
\hline
\end{DoxyParams}
\index{Object\+Manager@{Object\+Manager}!ibm\+\_\+move\+\_\+bodies@{ibm\+\_\+move\+\_\+bodies}}
\index{ibm\+\_\+move\+\_\+bodies@{ibm\+\_\+move\+\_\+bodies}!Object\+Manager@{Object\+Manager}}
\subsubsection[{\texorpdfstring{ibm\+\_\+move\+\_\+bodies()}{ibm_move_bodies()}}]{\setlength{\rightskip}{0pt plus 5cm}void Object\+Manager\+::ibm\+\_\+move\+\_\+bodies (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_object_manager_ad874ba69d231d4c1720c4e3a68ff3499}{}\label{class_object_manager_ad874ba69d231d4c1720c4e3a68ff3499}


Moves i\+Bodies after applying I\+BM. 

Wrapper for relocating markers of an i\+Body be calling appropriate positional update routine. \index{Object\+Manager@{Object\+Manager}!ibm\+\_\+position\+\_\+update@{ibm\+\_\+position\+\_\+update}}
\index{ibm\+\_\+position\+\_\+update@{ibm\+\_\+position\+\_\+update}!Object\+Manager@{Object\+Manager}}
\subsubsection[{\texorpdfstring{ibm\+\_\+position\+\_\+update(int ib)}{ibm_position_update(int ib)}}]{\setlength{\rightskip}{0pt plus 5cm}void Object\+Manager\+::ibm\+\_\+position\+\_\+update (
\begin{DoxyParamCaption}
\item[{int}]{ib}
\end{DoxyParamCaption}
)}\hypertarget{class_object_manager_a53eedab20e69a10ae861197b614751db}{}\label{class_object_manager_a53eedab20e69a10ae861197b614751db}


Update the position of a deformable i\+Body. 

Wrapper for applying external forcing or structural calculations to i\+Bodies marked as deformable. Updates support on completion.


\begin{DoxyParams}{Parameters}
{\em ib} & index of body to which calculation is to be applied. \\
\hline
\end{DoxyParams}
\index{Object\+Manager@{Object\+Manager}!ibm\+\_\+position\+\_\+update\+\_\+grp@{ibm\+\_\+position\+\_\+update\+\_\+grp}}
\index{ibm\+\_\+position\+\_\+update\+\_\+grp@{ibm\+\_\+position\+\_\+update\+\_\+grp}!Object\+Manager@{Object\+Manager}}
\subsubsection[{\texorpdfstring{ibm\+\_\+position\+\_\+update\+\_\+grp(int group)}{ibm_position_update_grp(int group)}}]{\setlength{\rightskip}{0pt plus 5cm}void Object\+Manager\+::ibm\+\_\+position\+\_\+update\+\_\+grp (
\begin{DoxyParamCaption}
\item[{int}]{group}
\end{DoxyParamCaption}
)}\hypertarget{class_object_manager_ae8f08e2935c8999db99b41a3c97b63c5}{}\label{class_object_manager_ae8f08e2935c8999db99b41a3c97b63c5}


Update the position of a group of deformable i\+Bodies. 

Updates the position of a group of non-\/flexible moving (deformable) bodies by using the first flexible body in the group as the driver. Must be called after all previous positional update routines have been called.


\begin{DoxyParams}{Parameters}
{\em group} & group ID to be updated. \\
\hline
\end{DoxyParams}
\index{Object\+Manager@{Object\+Manager}!ibm\+\_\+spread@{ibm\+\_\+spread}}
\index{ibm\+\_\+spread@{ibm\+\_\+spread}!Object\+Manager@{Object\+Manager}}
\subsubsection[{\texorpdfstring{ibm\+\_\+spread(int ib)}{ibm_spread(int ib)}}]{\setlength{\rightskip}{0pt plus 5cm}void Object\+Manager\+::ibm\+\_\+spread (
\begin{DoxyParamCaption}
\item[{int}]{ib}
\end{DoxyParamCaption}
)}\hypertarget{class_object_manager_a8096f9ec97cf7ce2fc45ebfcbdf3617e}{}\label{class_object_manager_a8096f9ec97cf7ce2fc45ebfcbdf3617e}


Spread restorative force back onto marker support. 


\begin{DoxyParams}{Parameters}
{\em ib} & i\+Body being operated on. \\
\hline
\end{DoxyParams}
\index{Object\+Manager@{Object\+Manager}!io\+\_\+read\+In\+Cloud@{io\+\_\+read\+In\+Cloud}}
\index{io\+\_\+read\+In\+Cloud@{io\+\_\+read\+In\+Cloud}!Object\+Manager@{Object\+Manager}}
\subsubsection[{\texorpdfstring{io\+\_\+read\+In\+Cloud(\+P\+Cpts $\ast$\+\_\+\+P\+Cpts, e\+Object\+Type objtype)}{io_readInCloud(PCpts *_PCpts, eObjectType objtype)}}]{\setlength{\rightskip}{0pt plus 5cm}void Object\+Manager\+::io\+\_\+read\+In\+Cloud (
\begin{DoxyParamCaption}
\item[{{\bf P\+Cpts} $\ast$}]{\+\_\+\+P\+Cpts, }
\item[{{\bf e\+Object\+Type}}]{objtype}
\end{DoxyParamCaption}
)}\hypertarget{class_object_manager_a5c11d747c3df9e91d5fc2dac836d7b7e}{}\label{class_object_manager_a5c11d747c3df9e91d5fc2dac836d7b7e}


Read in point cloud data. 

Input data must be in tab separated, 3-\/column format in the input directory.


\begin{DoxyParams}{Parameters}
{\em \+\_\+\+P\+Cpts} & pointer to empty point cloud data container. \\
\hline
{\em objtype} & type of object to be read in. \\
\hline
\end{DoxyParams}
\index{Object\+Manager@{Object\+Manager}!io\+\_\+restart@{io\+\_\+restart}}
\index{io\+\_\+restart@{io\+\_\+restart}!Object\+Manager@{Object\+Manager}}
\subsubsection[{\texorpdfstring{io\+\_\+restart(bool I\+O\+\_\+flag, int level)}{io_restart(bool IO_flag, int level)}}]{\setlength{\rightskip}{0pt plus 5cm}void Object\+Manager\+::io\+\_\+restart (
\begin{DoxyParamCaption}
\item[{bool}]{I\+O\+\_\+flag, }
\item[{int}]{level}
\end{DoxyParamCaption}
)}\hypertarget{class_object_manager_aaa1b7e2a3392c2a8d85606041b986b4d}{}\label{class_object_manager_aaa1b7e2a3392c2a8d85606041b986b4d}


Read/write IB body information to restart file. 


\begin{DoxyParams}{Parameters}
{\em I\+O\+\_\+flag} & flag indicating write (true) or read (false). \\
\hline
{\em level} & level of the grid begin written/read \\
\hline
\end{DoxyParams}
\index{Object\+Manager@{Object\+Manager}!io\+\_\+vtk\+\_\+\+I\+Bwriter@{io\+\_\+vtk\+\_\+\+I\+Bwriter}}
\index{io\+\_\+vtk\+\_\+\+I\+Bwriter@{io\+\_\+vtk\+\_\+\+I\+Bwriter}!Object\+Manager@{Object\+Manager}}
\subsubsection[{\texorpdfstring{io\+\_\+vtk\+\_\+\+I\+Bwriter(double tval)}{io_vtk_IBwriter(double tval)}}]{\setlength{\rightskip}{0pt plus 5cm}void Object\+Manager\+::io\+\_\+vtk\+\_\+\+I\+Bwriter (
\begin{DoxyParamCaption}
\item[{double}]{tval}
\end{DoxyParamCaption}
)}\hypertarget{class_object_manager_a39aa351c7b338473be4871111da5c5bd}{}\label{class_object_manager_a39aa351c7b338473be4871111da5c5bd}


Write IB body data to V\+TK file. 

Currently can only write out un-\/closed bodies like filaments.


\begin{DoxyParams}{Parameters}
{\em tval} & time value at which the write out is being performed. \\
\hline
\end{DoxyParams}
\index{Object\+Manager@{Object\+Manager}!io\+\_\+write\+\_\+body\+\_\+pos@{io\+\_\+write\+\_\+body\+\_\+pos}}
\index{io\+\_\+write\+\_\+body\+\_\+pos@{io\+\_\+write\+\_\+body\+\_\+pos}!Object\+Manager@{Object\+Manager}}
\subsubsection[{\texorpdfstring{io\+\_\+write\+\_\+body\+\_\+pos(int timestep)}{io_write_body_pos(int timestep)}}]{\setlength{\rightskip}{0pt plus 5cm}void Object\+Manager\+::io\+\_\+write\+\_\+body\+\_\+pos (
\begin{DoxyParamCaption}
\item[{int}]{timestep}
\end{DoxyParamCaption}
)}\hypertarget{class_object_manager_a1f9a40c58bdb3bd9797f7c44864835ec}{}\label{class_object_manager_a1f9a40c58bdb3bd9797f7c44864835ec}


Write out position of immersed boundary bodies. 


\begin{DoxyParams}{Parameters}
{\em timestep} & timestep at which the write out is being performed. \\
\hline
\end{DoxyParams}
\index{Object\+Manager@{Object\+Manager}!io\+\_\+write\+\_\+lift\+\_\+drag@{io\+\_\+write\+\_\+lift\+\_\+drag}}
\index{io\+\_\+write\+\_\+lift\+\_\+drag@{io\+\_\+write\+\_\+lift\+\_\+drag}!Object\+Manager@{Object\+Manager}}
\subsubsection[{\texorpdfstring{io\+\_\+write\+\_\+lift\+\_\+drag(int timestep)}{io_write_lift_drag(int timestep)}}]{\setlength{\rightskip}{0pt plus 5cm}void Object\+Manager\+::io\+\_\+write\+\_\+lift\+\_\+drag (
\begin{DoxyParamCaption}
\item[{int}]{timestep}
\end{DoxyParamCaption}
)}\hypertarget{class_object_manager_ab46e89c9eaf8ca1c9ec264545f39cd7f}{}\label{class_object_manager_ab46e89c9eaf8ca1c9ec264545f39cd7f}


Write out forces on the markers of immersed boundary bodies. 


\begin{DoxyParams}{Parameters}
{\em timestep} & timestep at which the write out is being performed. \\
\hline
\end{DoxyParams}
\index{Object\+Manager@{Object\+Manager}!io\+\_\+write\+Force\+On\+Object@{io\+\_\+write\+Force\+On\+Object}}
\index{io\+\_\+write\+Force\+On\+Object@{io\+\_\+write\+Force\+On\+Object}!Object\+Manager@{Object\+Manager}}
\subsubsection[{\texorpdfstring{io\+\_\+write\+Force\+On\+Object(double tval)}{io_writeForceOnObject(double tval)}}]{\setlength{\rightskip}{0pt plus 5cm}void Object\+Manager\+::io\+\_\+write\+Force\+On\+Object (
\begin{DoxyParamCaption}
\item[{double}]{tval}
\end{DoxyParamCaption}
)}\hypertarget{class_object_manager_adf65260d81584613fa33f2e7658f1b36}{}\label{class_object_manager_adf65260d81584613fa33f2e7658f1b36}


Write out the forces on a solid object. 

Writes out the forces on solid objects in the domain computed using momentum exchange. Each rank writes its own file. Output is a C\+SV file. 
\begin{DoxyParams}{Parameters}
{\em tval} & time value at which write out is taking place. \\
\hline
\end{DoxyParams}


\subsection{Friends And Related Function Documentation}
\index{Object\+Manager@{Object\+Manager}!Grid\+Obj@{Grid\+Obj}}
\index{Grid\+Obj@{Grid\+Obj}!Object\+Manager@{Object\+Manager}}
\subsubsection[{\texorpdfstring{Grid\+Obj}{GridObj}}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf Grid\+Obj}\hspace{0.3cm}{\ttfamily [friend]}}\hypertarget{class_object_manager_a55cfec1721fb1b9d9e7592bd6288c998}{}\label{class_object_manager_a55cfec1721fb1b9d9e7592bd6288c998}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
\hyperlink{_object_manager_8h}{Object\+Manager.\+h}\item 
\hyperlink{_object_manager_8cpp}{Object\+Manager.\+cpp}\item 
\hyperlink{_object_manager__init__bflbody_8cpp}{Object\+Manager\+\_\+init\+\_\+bflbody.\+cpp}\item 
\hyperlink{_object_manager__init__ibmbody_8cpp}{Object\+Manager\+\_\+init\+\_\+ibmbody.\+cpp}\item 
\hyperlink{_object_manager__ops__ibm_8cpp}{Object\+Manager\+\_\+ops\+\_\+ibm.\+cpp}\item 
\hyperlink{_object_manager__ops__ibmflex_8cpp}{Object\+Manager\+\_\+ops\+\_\+ibmflex.\+cpp}\item 
\hyperlink{_object_manager__ops__io_8cpp}{Object\+Manager\+\_\+ops\+\_\+io.\+cpp}\end{DoxyCompactItemize}
