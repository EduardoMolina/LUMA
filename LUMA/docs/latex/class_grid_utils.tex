\hypertarget{class_grid_utils}{}\section{Grid\+Utils Class Reference}
\label{class_grid_utils}\index{Grid\+Utils@{Grid\+Utils}}


Grid utility class.  




{\ttfamily \#include $<$Grid\+Utils.\+h$>$}

\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static void \hyperlink{class_grid_utils_af931614cb5eab6b906aa01106089b628}{create\+Output\+Directory} (std\+::string \hyperlink{class_grid_utils_a9b58748e9e05e84852962d7abc7942e3}{path\+\_\+str})
\begin{DoxyCompactList}\small\item\em Create output directory. \end{DoxyCompactList}\item 
static std\+::vector$<$ int $>$ \hyperlink{class_grid_utils_a1f0d4a76be76a743c368c9a1d4d46cbc}{onespace} (int min, int max)
\begin{DoxyCompactList}\small\item\em Creates a linearly-\/spaced vector of integers. \end{DoxyCompactList}\item 
static std\+::vector$<$ double $>$ \hyperlink{class_grid_utils_a2f172a6dd8b2749ca1c8336a64a07e29}{linspace} (double min, double max, int n)
\begin{DoxyCompactList}\small\item\em Creates a linearly-\/spaced vector of values. \end{DoxyCompactList}\item 
static double \hyperlink{class_grid_utils_a1e0d0da69ec1543835b98bca884f8927}{vecnorm} (double vec\mbox{[}\hyperlink{definitions_8h_a31d5945080ee5c34edc32e6f74c724c8}{L\+\_\+\+D\+I\+MS}\mbox{]})
\begin{DoxyCompactList}\small\item\em Computes the L2 norm using the vector supplied. \end{DoxyCompactList}\item 
static double \hyperlink{class_grid_utils_ae7d797edf50b3c3a448d59684a135aee}{vecnorm} (double val1, double val2)
\begin{DoxyCompactList}\small\item\em Computes the L2 norm using the vector components supplied. \end{DoxyCompactList}\item 
static double \hyperlink{class_grid_utils_a6caced99b15b01746c1fb5828c447034}{vecnorm} (double val1, double val2, double val3)
\begin{DoxyCompactList}\small\item\em Computes the L2 norm using the vector components supplied. \end{DoxyCompactList}\item 
static double \hyperlink{class_grid_utils_a45167f9bde2e34d868a4ccc64f588ab2}{vecnorm} (std\+::vector$<$ double $>$ vec)
\begin{DoxyCompactList}\small\item\em Computes the L2 norm using the vector supplied. \end{DoxyCompactList}\item 
static std\+::vector$<$ int $>$ \hyperlink{class_grid_utils_aee47fe58eccee5fffd67bb489fd1c315}{get\+Fine\+Indices} (int coarse\+\_\+i, int x\+\_\+start, int coarse\+\_\+j, int y\+\_\+start, int coarse\+\_\+k, int z\+\_\+start)
\begin{DoxyCompactList}\small\item\em Gets the indices of the fine site given the coarse site. \end{DoxyCompactList}\item 
static std\+::vector$<$ int $>$ \hyperlink{class_grid_utils_a4d3973d2b60fe6cac6e49e8640307958}{get\+Coarse\+Indices} (int fine\+\_\+i, int x\+\_\+start, int fine\+\_\+j, int y\+\_\+start, int fine\+\_\+k, int z\+\_\+start)
\begin{DoxyCompactList}\small\item\em Gets the indices of the coarse site given the fine site. \end{DoxyCompactList}\item 
static double \hyperlink{class_grid_utils_af374256beaf42d97b23f7d98af93a3f1}{dotprod} (std\+::vector$<$ double $>$ vec1, std\+::vector$<$ double $>$ vec2)
\begin{DoxyCompactList}\small\item\em Computes the scalar product of two vectors. \end{DoxyCompactList}\item 
static std\+::vector$<$ double $>$ \hyperlink{class_grid_utils_a6f5af65d6bb25e0d34be50670b41514f}{subtract} (std\+::vector$<$ double $>$ a, std\+::vector$<$ double $>$ b)
\begin{DoxyCompactList}\small\item\em Subtracts two vectors. \end{DoxyCompactList}\item 
static std\+::vector$<$ double $>$ \hyperlink{class_grid_utils_a4e9fc081a19660e9db39428014c04a9c}{add} (std\+::vector$<$ double $>$ a, std\+::vector$<$ double $>$ b)
\begin{DoxyCompactList}\small\item\em Adds two vectors. \end{DoxyCompactList}\item 
static std\+::vector$<$ double $>$ \hyperlink{class_grid_utils_a01eba1d90d3414637d5031850ad89ce3}{vecmultiply} (double scalar, std\+::vector$<$ double $>$ vec)
\begin{DoxyCompactList}\small\item\em Multiplies a scalar by a vector. \end{DoxyCompactList}\item 
static std\+::vector$<$ double $>$ \hyperlink{class_grid_utils_aeb315c03a681483339de9f60ab2964d6}{crossprod} (std\+::vector$<$ double $>$ vec1, std\+::vector$<$ double $>$ vec2)
\begin{DoxyCompactList}\small\item\em Computes vector product. \end{DoxyCompactList}\item 
static std\+::vector$<$ double $>$ \hyperlink{class_grid_utils_a0051918813c63802d79bd7d172e8ad8a}{matrix\+\_\+multiply} (const std\+::vector$<$ std\+::vector$<$ double $>$ $>$ \&A, const std\+::vector$<$ double $>$ \&x)
\begin{DoxyCompactList}\small\item\em Multiplies matrix A by vector x. \end{DoxyCompactList}\item 
static int \hyperlink{class_grid_utils_af3c54e468658879756c71b01abd028d5}{get\+Opposite} (int direction)
\begin{DoxyCompactList}\small\item\em Gets the opposite lattice direction to the one supplied. \end{DoxyCompactList}\item 
static void \hyperlink{class_grid_utils_afac10170d3f6f96a32da6a783b815954}{get\+Grid} (\hyperlink{class_grid_obj}{Grid\+Obj} $\ast$\&Grids, int level, int region, \hyperlink{class_grid_obj}{Grid\+Obj} $\ast$\&ptr)
\begin{DoxyCompactList}\small\item\em Get a pointer to a given grid in the hierarchy. \end{DoxyCompactList}\item 
static bool \hyperlink{class_grid_utils_a7c13884020ab181ee8cb6dd2ea7e4fd7}{is\+Overlap\+Periodic} (int i, int j, int k, const \hyperlink{class_grid_obj}{Grid\+Obj} \&p\+Grid)
\begin{DoxyCompactList}\small\item\em Finds out whether halo containng i,j,k links to neighbour rank periodically. \end{DoxyCompactList}\item 
static bool \hyperlink{class_grid_utils_adcf9512bd143ac0b9ef7eec33f1510ec}{is\+On\+This\+Rank} (double x, double y, double z, \hyperlink{_grid_utils_8h_a478f1e2cf9934de79a892e60980598dc}{e\+Location\+On\+Rank} loc=\hyperlink{_grid_utils_8h_a478f1e2cf9934de79a892e60980598dca6505acf15690a324459e652a94fc339a}{e\+None}, const \hyperlink{class_grid_obj}{Grid\+Obj} $\ast$grid=nullptr, std\+::vector$<$ int $>$ $\ast$pos=nullptr)
\begin{DoxyCompactList}\small\item\em Finds out whether site with supplied position is on the current rank. \end{DoxyCompactList}\item 
static bool \hyperlink{class_grid_utils_a4eca1ee0dff756b5cd65d45f84b24118}{is\+On\+This\+Rank} (double xyz, \hyperlink{_grid_utils_8h_afbad8e4a2f1e9903755b1bd2fe8273cf}{e\+Cartesian\+Direction} dir, \hyperlink{_grid_utils_8h_a478f1e2cf9934de79a892e60980598dc}{e\+Location\+On\+Rank} loc=\hyperlink{_grid_utils_8h_a478f1e2cf9934de79a892e60980598dca6505acf15690a324459e652a94fc339a}{e\+None}, const \hyperlink{class_grid_obj}{Grid\+Obj} $\ast$grid=nullptr, int $\ast$pos=nullptr)
\begin{DoxyCompactList}\small\item\em Finds out whether the supplied position can be found on the current rank. \end{DoxyCompactList}\item 
static bool \hyperlink{class_grid_utils_a14da5d778eb6d81fbcd5c9331a8082dd}{intersects\+Refined\+Region} (const \hyperlink{class_grid_obj}{Grid\+Obj} \&p\+Grid, int Reg\+Num)
\begin{DoxyCompactList}\small\item\em Finds out whether all or part of specified refined region intersects with the space occupied by the grid provided. \end{DoxyCompactList}\item 
static bool \hyperlink{class_grid_utils_af0692236725709af2d98872805fc84ae}{is\+On\+Sender\+Layer} (double pos\+\_\+x, double pos\+\_\+y, double pos\+\_\+z)
\begin{DoxyCompactList}\small\item\em Check whether site is on an inner (sender) halo. \end{DoxyCompactList}\item 
static bool \hyperlink{class_grid_utils_abfec29d90b6942de2f3c52c225a4d888}{is\+On\+Recv\+Layer} (double pos\+\_\+x, double pos\+\_\+y, double pos\+\_\+z)
\begin{DoxyCompactList}\small\item\em Check whether site is on an outer (receiver) halo. \end{DoxyCompactList}\item 
static bool \hyperlink{class_grid_utils_a595b78d268cdbc0e6a3b008ac93e0cb4}{is\+On\+Sender\+Layer} (double site\+\_\+position, \hyperlink{_grid_utils_8h_afbad8e4a2f1e9903755b1bd2fe8273cf}{e\+Cartesian\+Direction} dir, \hyperlink{_grid_utils_8h_a8e005b039da2246588381c4feeeac43f}{e\+Min\+Max} minmax)
\begin{DoxyCompactList}\small\item\em Check whether site is on an inner (sender) halo. \end{DoxyCompactList}\item 
static bool \hyperlink{class_grid_utils_a0fb32f233e85584a04856c6c67299d68}{is\+On\+Recv\+Layer} (double site\+\_\+position, \hyperlink{_grid_utils_8h_afbad8e4a2f1e9903755b1bd2fe8273cf}{e\+Cartesian\+Direction} dir, \hyperlink{_grid_utils_8h_a8e005b039da2246588381c4feeeac43f}{e\+Min\+Max} minmax)
\begin{DoxyCompactList}\small\item\em Check whether site is on an outer (receiver) halo. \end{DoxyCompactList}\item 
static int \hyperlink{class_grid_utils_a1a59da2eb58afd9e785b45b23ad962df}{get\+Mpi\+Direction} (int offset\+\_\+vector\mbox{[}$\,$\mbox{]})
\begin{DoxyCompactList}\small\item\em Get direction in M\+PI topology from unit vector. \end{DoxyCompactList}\item 
static bool \hyperlink{class_grid_utils_acb35c1a485e74c0b2794b84573b5e50f}{is\+Off\+Grid} (int i, int j, int k, const \hyperlink{class_grid_obj}{Grid\+Obj} $\ast$g)
\begin{DoxyCompactList}\small\item\em Tests whether a site is on a given grid. \end{DoxyCompactList}\item 
static void \hyperlink{class_grid_utils_ad0c030776101d001fda37eb7f90d2b20}{get\+Enclosing\+Voxel} (double x, double y, double z, const \hyperlink{class_grid_obj}{Grid\+Obj} $\ast$g, std\+::vector$<$ int $>$ $\ast$ijk)
\begin{DoxyCompactList}\small\item\em Get local voxel indices on grid in which provided position lies. \end{DoxyCompactList}\item 
static void \hyperlink{class_grid_utils_a20901145122cf56507713abe0467638c}{get\+Enclosing\+Voxel} (double x, const \hyperlink{class_grid_obj}{Grid\+Obj} $\ast$g, \hyperlink{_grid_utils_8h_afbad8e4a2f1e9903755b1bd2fe8273cf}{e\+Cartesian\+Direction} dir, int $\ast$ijk)
\begin{DoxyCompactList}\small\item\em Get local voxel indices on grid in which provided position lies. \end{DoxyCompactList}\item 
static bool \hyperlink{class_grid_utils_a78d9c31d1c15198d1455627d1fa29804}{is\+On\+Transition\+Layer} (double pos\+\_\+x, double pos\+\_\+y, double pos\+\_\+z, const \hyperlink{class_grid_obj}{Grid\+Obj} $\ast$grid)
\begin{DoxyCompactList}\small\item\em Check whether site is on a TL. \end{DoxyCompactList}\item 
static bool \hyperlink{class_grid_utils_af241bda5fffef58362b1e77d9d3de6dc}{is\+On\+Transition\+Layer} (double position, \hyperlink{_grid_utils_8h_afbad8e4a2f1e9903755b1bd2fe8273cf}{e\+Cartesian\+Direction} dir, \hyperlink{_grid_utils_8h_a8e005b039da2246588381c4feeeac43f}{e\+Min\+Max} minmax, const \hyperlink{class_grid_obj}{Grid\+Obj} $\ast$grid)
\begin{DoxyCompactList}\small\item\em Check whether site is on a specific TL (to upper). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Num\+Type $>$ }\\static Num\+Type \hyperlink{class_grid_utils_a78aa4876d7066bce253c52457e7b901d}{vecnorm} (Num\+Type a1, Num\+Type a2, Num\+Type a3)
\begin{DoxyCompactList}\small\item\em Computes the L2-\/norm. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Num\+Type $>$ }\\static Num\+Type \hyperlink{class_grid_utils_a7a169fc043a585f20936b314def45fe7}{vecnorm} (Num\+Type a1, Num\+Type a2)
\begin{DoxyCompactList}\small\item\em Computes the L2-\/norm. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Num\+Type $>$ }\\static Num\+Type \hyperlink{class_grid_utils_a5a3e26a94e62833f0a9e5a4bda066dac}{up\+To\+Zero} (Num\+Type x)
\begin{DoxyCompactList}\small\item\em Rounds a negative value up to zero. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Num\+Type $>$ }\\static Num\+Type \hyperlink{class_grid_utils_abd4068e22339d5272ca551f8cbddec26}{down\+To\+Limit} (Num\+Type x, Num\+Type limit)
\begin{DoxyCompactList}\small\item\em Rounds a value greater than a limit down to this value. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Num\+Type $>$ }\\static Num\+Type \hyperlink{class_grid_utils_a57edeaeba2d67d187a9edd0b560fe0c2}{factorial} (Num\+Type n)
\begin{DoxyCompactList}\small\item\em Computes the factorial of the supplied value. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Num\+Type $>$ }\\static void \hyperlink{class_grid_utils_aa3ca6e20ef4fa927cb845956d7565b1e}{strided\+Copy} (Num\+Type $\ast$dest, Num\+Type $\ast$src, size\+\_\+t block, size\+\_\+t offset, size\+\_\+t stride, size\+\_\+t count, size\+\_\+t buf\+\_\+offset=0)
\begin{DoxyCompactList}\small\item\em Performs a strided memcpy. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static std\+::ofstream $\ast$ \hyperlink{class_grid_utils_a298239096e929c1ba4eba925e351c1b3}{logfile}
\begin{DoxyCompactList}\small\item\em Handle to output file. \end{DoxyCompactList}\item 
static std\+::string \hyperlink{class_grid_utils_a9b58748e9e05e84852962d7abc7942e3}{path\+\_\+str}
\begin{DoxyCompactList}\small\item\em Static string representing output path. \end{DoxyCompactList}\item 
static const int \hyperlink{class_grid_utils_ae2b566735d973bc25f1a6416010efa70}{dir\+\_\+reflect} \mbox{[}\hyperlink{definitions_8h_a31d5945080ee5c34edc32e6f74c724c8}{L\+\_\+\+D\+I\+MS} $\ast$2\mbox{]}\mbox{[}\hyperlink{definitions_8h_a947c7e248feb63ae57fb828c03c4c001}{L\+\_\+\+N\+U\+M\+\_\+\+V\+E\+LS}\mbox{]}
\begin{DoxyCompactList}\small\item\em Array with hardcoded direction numbering for specular reflection. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Grid utility class. 

Class provides grid utilities including commonly used logical tests. This is a static class and so there is no need to instantiate it. 

\subsection{Member Function Documentation}
\index{Grid\+Utils@{Grid\+Utils}!add@{add}}
\index{add@{add}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{add(std\+::vector$<$ double $>$ a, std\+::vector$<$ double $>$ b)}{add(std::vector< double > a, std::vector< double > b)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<$ double $>$ Grid\+Utils\+::add (
\begin{DoxyParamCaption}
\item[{std\+::vector$<$ double $>$}]{a, }
\item[{std\+::vector$<$ double $>$}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_grid_utils_a4e9fc081a19660e9db39428014c04a9c}{}\label{class_grid_utils_a4e9fc081a19660e9db39428014c04a9c}


Adds two vectors. 


\begin{DoxyParams}{Parameters}
{\em a} & a vector. \\
\hline
{\em b} & a second vector. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
vector which is a + b. 
\end{DoxyReturn}
\index{Grid\+Utils@{Grid\+Utils}!create\+Output\+Directory@{create\+Output\+Directory}}
\index{create\+Output\+Directory@{create\+Output\+Directory}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{create\+Output\+Directory(std\+::string path\+\_\+str)}{createOutputDirectory(std::string path_str)}}]{\setlength{\rightskip}{0pt plus 5cm}void Grid\+Utils\+::create\+Output\+Directory (
\begin{DoxyParamCaption}
\item[{std\+::string}]{path\+\_\+str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_grid_utils_af931614cb5eab6b906aa01106089b628}{}\label{class_grid_utils_af931614cb5eab6b906aa01106089b628}


Create output directory. 

Compatible with both Windows and Linux. Filename and path passed as a single string. Returns nothing at the moment.


\begin{DoxyParams}{Parameters}
{\em path\+\_\+str} & full path and filename as string. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
indicator of status of action. 
\end{DoxyReturn}
\index{Grid\+Utils@{Grid\+Utils}!crossprod@{crossprod}}
\index{crossprod@{crossprod}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{crossprod(std\+::vector$<$ double $>$ vec1, std\+::vector$<$ double $>$ vec2)}{crossprod(std::vector< double > vec1, std::vector< double > vec2)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<$ double $>$ Grid\+Utils\+::crossprod (
\begin{DoxyParamCaption}
\item[{std\+::vector$<$ double $>$}]{a, }
\item[{std\+::vector$<$ double $>$}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_grid_utils_aeb315c03a681483339de9f60ab2964d6}{}\label{class_grid_utils_aeb315c03a681483339de9f60ab2964d6}


Computes vector product. 


\begin{DoxyParams}{Parameters}
{\em a} & a vector. \\
\hline
{\em b} & a second vector. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a vector which is the cross product of a and b. 
\end{DoxyReturn}
\index{Grid\+Utils@{Grid\+Utils}!dotprod@{dotprod}}
\index{dotprod@{dotprod}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{dotprod(std\+::vector$<$ double $>$ vec1, std\+::vector$<$ double $>$ vec2)}{dotprod(std::vector< double > vec1, std::vector< double > vec2)}}]{\setlength{\rightskip}{0pt plus 5cm}double Grid\+Utils\+::dotprod (
\begin{DoxyParamCaption}
\item[{std\+::vector$<$ double $>$}]{vec1, }
\item[{std\+::vector$<$ double $>$}]{vec2}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_grid_utils_af374256beaf42d97b23f7d98af93a3f1}{}\label{class_grid_utils_af374256beaf42d97b23f7d98af93a3f1}


Computes the scalar product of two vectors. 


\begin{DoxyParams}{Parameters}
{\em vec1} & a vector. \\
\hline
{\em vec2} & a second vector. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the dot product of the two vectors. 
\end{DoxyReturn}
\index{Grid\+Utils@{Grid\+Utils}!down\+To\+Limit@{down\+To\+Limit}}
\index{down\+To\+Limit@{down\+To\+Limit}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{down\+To\+Limit(\+Num\+Type x, Num\+Type limit)}{downToLimit(NumType x, NumType limit)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Num\+Type $>$ static Num\+Type Grid\+Utils\+::down\+To\+Limit (
\begin{DoxyParamCaption}
\item[{Num\+Type}]{x, }
\item[{Num\+Type}]{limit}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{class_grid_utils_abd4068e22339d5272ca551f8cbddec26}{}\label{class_grid_utils_abd4068e22339d5272ca551f8cbddec26}


Rounds a value greater than a limit down to this value. 

If value is less than or equal to the limit, return the value unchanged.


\begin{DoxyParams}{Parameters}
{\em x} & value to be rounded \\
\hline
{\em limit} & value to be rounded down to \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Num\+Type rounded value 
\end{DoxyReturn}
\index{Grid\+Utils@{Grid\+Utils}!factorial@{factorial}}
\index{factorial@{factorial}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{factorial(\+Num\+Type n)}{factorial(NumType n)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Num\+Type $>$ static Num\+Type Grid\+Utils\+::factorial (
\begin{DoxyParamCaption}
\item[{Num\+Type}]{n}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{class_grid_utils_a57edeaeba2d67d187a9edd0b560fe0c2}{}\label{class_grid_utils_a57edeaeba2d67d187a9edd0b560fe0c2}


Computes the factorial of the supplied value. 

If n == 0 then returns 1.


\begin{DoxyParams}{Parameters}
{\em n} & factorial \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Num\+Type n factorial 
\end{DoxyReturn}
\index{Grid\+Utils@{Grid\+Utils}!get\+Coarse\+Indices@{get\+Coarse\+Indices}}
\index{get\+Coarse\+Indices@{get\+Coarse\+Indices}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{get\+Coarse\+Indices(int fine\+\_\+i, int x\+\_\+start, int fine\+\_\+j, int y\+\_\+start, int fine\+\_\+k, int z\+\_\+start)}{getCoarseIndices(int fine_i, int x_start, int fine_j, int y_start, int fine_k, int z_start)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<$ int $>$ Grid\+Utils\+::get\+Coarse\+Indices (
\begin{DoxyParamCaption}
\item[{int}]{fine\+\_\+i, }
\item[{int}]{x\+\_\+start, }
\item[{int}]{fine\+\_\+j, }
\item[{int}]{y\+\_\+start, }
\item[{int}]{fine\+\_\+k, }
\item[{int}]{z\+\_\+start}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_grid_utils_a4d3973d2b60fe6cac6e49e8640307958}{}\label{class_grid_utils_a4d3973d2b60fe6cac6e49e8640307958}


Gets the indices of the coarse site given the fine site. 

Maps the indices of a fine grid site to a corresponding coarse site on the level above.


\begin{DoxyParams}{Parameters}
{\em fine\+\_\+i} & local i-\/index of fine site to be mapped. \\
\hline
{\em x\+\_\+start} & local x-\/index of start of refined region on the grid above. \\
\hline
{\em fine\+\_\+j} & local j-\/index of fine site to be mapped. \\
\hline
{\em y\+\_\+start} & local y-\/index of start of refined region on the grid above. \\
\hline
{\em fine\+\_\+k} & local k-\/index of fine site to be mapped. \\
\hline
{\em z\+\_\+start} & local z-\/index of start of refined region on the grid above. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
local indices of the coarse grid site. 
\end{DoxyReturn}
\index{Grid\+Utils@{Grid\+Utils}!get\+Enclosing\+Voxel@{get\+Enclosing\+Voxel}}
\index{get\+Enclosing\+Voxel@{get\+Enclosing\+Voxel}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{get\+Enclosing\+Voxel(double x, double y, double z, const Grid\+Obj $\ast$g, std\+::vector$<$ int $>$ $\ast$ijk)}{getEnclosingVoxel(double x, double y, double z, const GridObj *g, std::vector< int > *ijk)}}]{\setlength{\rightskip}{0pt plus 5cm}void Grid\+Utils\+::get\+Enclosing\+Voxel (
\begin{DoxyParamCaption}
\item[{double}]{x, }
\item[{double}]{y, }
\item[{double}]{z, }
\item[{const {\bf Grid\+Obj} $\ast$}]{g, }
\item[{std\+::vector$<$ int $>$ $\ast$}]{ijk}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_grid_utils_ad0c030776101d001fda37eb7f90d2b20}{}\label{class_grid_utils_ad0c030776101d001fda37eb7f90d2b20}


Get local voxel indices on grid in which provided position lies. 

Wrapper for the overload which concentates all check into a vector.


\begin{DoxyParams}{Parameters}
{\em x} & x-\/position. \\
\hline
{\em y} & y-\/position. \\
\hline
{\em z} & z-\/position. \\
\hline
{\em g} & lattice on which to look for enclosing voxel. \\
\hline
{\em ijk} & pointer to vector where indices are to be placed. \\
\hline
\end{DoxyParams}
\index{Grid\+Utils@{Grid\+Utils}!get\+Enclosing\+Voxel@{get\+Enclosing\+Voxel}}
\index{get\+Enclosing\+Voxel@{get\+Enclosing\+Voxel}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{get\+Enclosing\+Voxel(double x, const Grid\+Obj $\ast$g, e\+Cartesian\+Direction dir, int $\ast$ijk)}{getEnclosingVoxel(double x, const GridObj *g, eCartesianDirection dir, int *ijk)}}]{\setlength{\rightskip}{0pt plus 5cm}void Grid\+Utils\+::get\+Enclosing\+Voxel (
\begin{DoxyParamCaption}
\item[{double}]{xyz, }
\item[{const {\bf Grid\+Obj} $\ast$}]{g, }
\item[{{\bf e\+Cartesian\+Direction}}]{dir, }
\item[{int $\ast$}]{ijk}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_grid_utils_a20901145122cf56507713abe0467638c}{}\label{class_grid_utils_a20901145122cf56507713abe0467638c}


Get local voxel indices on grid in which provided position lies. 

Will return the 1D voxel index of the voxel on the lattice provided within which point with position (xyz) lies. This is done by rounding the position to obtain how many voxels in from the grid core edge it is, then accounting for whether the grid starts on another rank, in the halo, or further into the grid by offsetting the original index by this amount. This approach saves expensive seraches of the position vectors on each grid. This method can be used as a position -\/$>$ voxel converter. The index may be off grid so it is advisable to call is\+On\+This\+Rank instead.


\begin{DoxyParams}{Parameters}
{\em xyz} & x, y or z-\/position. \\
\hline
{\em g} & lattice on which to look for enclosing voxel. \\
\hline
{\em dir} & 1D direction. \\
\hline
{\em ijk} & pointer to local index storage location. \\
\hline
\end{DoxyParams}
\index{Grid\+Utils@{Grid\+Utils}!get\+Fine\+Indices@{get\+Fine\+Indices}}
\index{get\+Fine\+Indices@{get\+Fine\+Indices}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{get\+Fine\+Indices(int coarse\+\_\+i, int x\+\_\+start, int coarse\+\_\+j, int y\+\_\+start, int coarse\+\_\+k, int z\+\_\+start)}{getFineIndices(int coarse_i, int x_start, int coarse_j, int y_start, int coarse_k, int z_start)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<$ int $>$ Grid\+Utils\+::get\+Fine\+Indices (
\begin{DoxyParamCaption}
\item[{int}]{coarse\+\_\+i, }
\item[{int}]{x\+\_\+start, }
\item[{int}]{coarse\+\_\+j, }
\item[{int}]{y\+\_\+start, }
\item[{int}]{coarse\+\_\+k, }
\item[{int}]{z\+\_\+start}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_grid_utils_aee47fe58eccee5fffd67bb489fd1c315}{}\label{class_grid_utils_aee47fe58eccee5fffd67bb489fd1c315}


Gets the indices of the fine site given the coarse site. 

Maps the indices of a coarse grid site to a corresponding fine site on the level below.


\begin{DoxyParams}{Parameters}
{\em coarse\+\_\+i} & local i-\/index of coarse site to be mapped. \\
\hline
{\em x\+\_\+start} & local x-\/index of start of refined region. \\
\hline
{\em coarse\+\_\+j} & local j-\/index of coarse site to be mapped. \\
\hline
{\em y\+\_\+start} & local y-\/index of start of refined region. \\
\hline
{\em coarse\+\_\+k} & local k-\/index of coarse site to be mapped. \\
\hline
{\em z\+\_\+start} & local z-\/index of start of refined region. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
local indices of the fine grid site. 
\end{DoxyReturn}
\index{Grid\+Utils@{Grid\+Utils}!get\+Grid@{get\+Grid}}
\index{get\+Grid@{get\+Grid}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{get\+Grid(\+Grid\+Obj $\ast$\&\+Grids, int level, int region, Grid\+Obj $\ast$\&ptr)}{getGrid(GridObj *&Grids, int level, int region, GridObj *&ptr)}}]{\setlength{\rightskip}{0pt plus 5cm}void Grid\+Utils\+::get\+Grid (
\begin{DoxyParamCaption}
\item[{{\bf Grid\+Obj} $\ast$\&}]{Grids, }
\item[{int}]{level, }
\item[{int}]{region, }
\item[{{\bf Grid\+Obj} $\ast$\&}]{ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_grid_utils_afac10170d3f6f96a32da6a783b815954}{}\label{class_grid_utils_afac10170d3f6f96a32da6a783b815954}


Get a pointer to a given grid in the hierarchy. 

Takes a N\+U\+LL pointer by reference and updates it when matching grid is found in hierarchy on this rank. If grid not found, pointer is returned without change and stays N\+U\+LL. Can be used to test for the existence of a grid on a rank by passing in a N\+U\+LL pointer and checking if a N\+U\+LL pointer is returned.


\begin{DoxyParams}[1]{Parameters}
 & {\em Grids} & x-\/position of site. \\
\hline
 & {\em level} & y-\/position of site. \\
\hline
 & {\em region} & z-\/position of site. \\
\hline
\mbox{\tt out}  & {\em ptr} & pointer containing address of grid in hierarchy. \\
\hline
\end{DoxyParams}
\index{Grid\+Utils@{Grid\+Utils}!get\+Mpi\+Direction@{get\+Mpi\+Direction}}
\index{get\+Mpi\+Direction@{get\+Mpi\+Direction}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{get\+Mpi\+Direction(int offset\+\_\+vector[])}{getMpiDirection(int offset_vector[])}}]{\setlength{\rightskip}{0pt plus 5cm}int Grid\+Utils\+::get\+Mpi\+Direction (
\begin{DoxyParamCaption}
\item[{int}]{offset\+\_\+vector\mbox{[}$\,$\mbox{]}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_grid_utils_a1a59da2eb58afd9e785b45b23ad962df}{}\label{class_grid_utils_a1a59da2eb58afd9e785b45b23ad962df}


Get direction in M\+PI topology from unit vector. 


\begin{DoxyParams}{Parameters}
{\em offset\+\_\+vector} & unit vector pointing away from current rank. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
M\+PI direction. 
\end{DoxyReturn}
\index{Grid\+Utils@{Grid\+Utils}!get\+Opposite@{get\+Opposite}}
\index{get\+Opposite@{get\+Opposite}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{get\+Opposite(int direction)}{getOpposite(int direction)}}]{\setlength{\rightskip}{0pt plus 5cm}int Grid\+Utils\+::get\+Opposite (
\begin{DoxyParamCaption}
\item[{int}]{direction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_grid_utils_af3c54e468658879756c71b01abd028d5}{}\label{class_grid_utils_af3c54e468658879756c71b01abd028d5}


Gets the opposite lattice direction to the one supplied. 

This is model independent as long as the model directions are specified such that the oppoiste direction is either one vector on or one vector back in the listing depending on whether the direction supplied is even or odd.


\begin{DoxyParams}{Parameters}
{\em direction} & direction to be reversed. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
opposite direction in lattice model. 
\end{DoxyReturn}
\index{Grid\+Utils@{Grid\+Utils}!intersects\+Refined\+Region@{intersects\+Refined\+Region}}
\index{intersects\+Refined\+Region@{intersects\+Refined\+Region}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{intersects\+Refined\+Region(const Grid\+Obj \&p\+Grid, int Reg\+Num)}{intersectsRefinedRegion(const GridObj &pGrid, int RegNum)}}]{\setlength{\rightskip}{0pt plus 5cm}bool Grid\+Utils\+::intersects\+Refined\+Region (
\begin{DoxyParamCaption}
\item[{const {\bf Grid\+Obj} \&}]{p\+Grid, }
\item[{int}]{Reg\+Num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_grid_utils_a14da5d778eb6d81fbcd5c9331a8082dd}{}\label{class_grid_utils_a14da5d778eb6d81fbcd5c9331a8082dd}


Finds out whether all or part of specified refined region intersects with the space occupied by the grid provided. 

Prinicpal use is for sub-\/grid initialisation to determine whether a sub-\/grid needs adding or not. This decision is made based on whether any part of the grid is covered by the discrete voxels of existing grids on the rank.


\begin{DoxyParams}{Parameters}
{\em p\+Grid} & parent grid at appropriate level. \\
\hline
{\em Reg\+Num} & region number desired. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
boolean answer. 
\end{DoxyReturn}
\index{Grid\+Utils@{Grid\+Utils}!is\+Off\+Grid@{is\+Off\+Grid}}
\index{is\+Off\+Grid@{is\+Off\+Grid}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{is\+Off\+Grid(int i, int j, int k, const Grid\+Obj $\ast$g)}{isOffGrid(int i, int j, int k, const GridObj *g)}}]{\setlength{\rightskip}{0pt plus 5cm}bool Grid\+Utils\+::is\+Off\+Grid (
\begin{DoxyParamCaption}
\item[{int}]{i, }
\item[{int}]{j, }
\item[{int}]{k, }
\item[{const {\bf Grid\+Obj} $\ast$}]{g}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_grid_utils_acb35c1a485e74c0b2794b84573b5e50f}{}\label{class_grid_utils_acb35c1a485e74c0b2794b84573b5e50f}


Tests whether a site is on a given grid. 


\begin{DoxyParams}{Parameters}
{\em i} & local i-\/index. \\
\hline
{\em j} & local j-\/index. \\
\hline
{\em k} & local k-\/index. \\
\hline
{\em g} & grid on which to check. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
boolean answer. 
\end{DoxyReturn}
\index{Grid\+Utils@{Grid\+Utils}!is\+On\+Recv\+Layer@{is\+On\+Recv\+Layer}}
\index{is\+On\+Recv\+Layer@{is\+On\+Recv\+Layer}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{is\+On\+Recv\+Layer(double pos\+\_\+x, double pos\+\_\+y, double pos\+\_\+z)}{isOnRecvLayer(double pos_x, double pos_y, double pos_z)}}]{\setlength{\rightskip}{0pt plus 5cm}bool Grid\+Utils\+::is\+On\+Recv\+Layer (
\begin{DoxyParamCaption}
\item[{double}]{pos\+\_\+x, }
\item[{double}]{pos\+\_\+y, }
\item[{double}]{pos\+\_\+z}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_grid_utils_abfec29d90b6942de2f3c52c225a4d888}{}\label{class_grid_utils_abfec29d90b6942de2f3c52c225a4d888}


Check whether site is on an outer (receiver) halo. 

Wrapper which checks every halo region of the rank for intersection with supplied site position.


\begin{DoxyParams}{Parameters}
{\em pos\+\_\+x} & x-\/position of site. \\
\hline
{\em pos\+\_\+y} & y-\/position of site. \\
\hline
{\em pos\+\_\+z} & z-\/position of site. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
boolean answer. 
\end{DoxyReturn}
\index{Grid\+Utils@{Grid\+Utils}!is\+On\+Recv\+Layer@{is\+On\+Recv\+Layer}}
\index{is\+On\+Recv\+Layer@{is\+On\+Recv\+Layer}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{is\+On\+Recv\+Layer(double site\+\_\+position, e\+Cartesian\+Direction dir, e\+Min\+Max minmax)}{isOnRecvLayer(double site_position, eCartesianDirection dir, eMinMax minmax)}}]{\setlength{\rightskip}{0pt plus 5cm}bool Grid\+Utils\+::is\+On\+Recv\+Layer (
\begin{DoxyParamCaption}
\item[{double}]{site\+\_\+position, }
\item[{{\bf e\+Cartesian\+Direction}}]{dir, }
\item[{{\bf e\+Min\+Max}}]{minmax}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_grid_utils_a0fb32f233e85584a04856c6c67299d68}{}\label{class_grid_utils_a0fb32f233e85584a04856c6c67299d68}


Check whether site is on an outer (receiver) halo. 

Wrapper available which checks every halo. This method only checks the halo specified by the Cartesian direction and whether it is the left/bottom/front (minimum) or right/top/back (maximum) edge of the block.


\begin{DoxyParams}{Parameters}
{\em site\+\_\+position} & position of site. \\
\hline
{\em dir} & cartesian direction. \\
\hline
{\em minmax} & choice of edge in given direction. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
boolean answer. 
\end{DoxyReturn}
\index{Grid\+Utils@{Grid\+Utils}!is\+On\+Sender\+Layer@{is\+On\+Sender\+Layer}}
\index{is\+On\+Sender\+Layer@{is\+On\+Sender\+Layer}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{is\+On\+Sender\+Layer(double pos\+\_\+x, double pos\+\_\+y, double pos\+\_\+z)}{isOnSenderLayer(double pos_x, double pos_y, double pos_z)}}]{\setlength{\rightskip}{0pt plus 5cm}bool Grid\+Utils\+::is\+On\+Sender\+Layer (
\begin{DoxyParamCaption}
\item[{double}]{pos\+\_\+x, }
\item[{double}]{pos\+\_\+y, }
\item[{double}]{pos\+\_\+z}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_grid_utils_af0692236725709af2d98872805fc84ae}{}\label{class_grid_utils_af0692236725709af2d98872805fc84ae}


Check whether site is on an inner (sender) halo. 

Wrapper which checks every halo region of the rank for intersection with supplied site position.


\begin{DoxyParams}{Parameters}
{\em pos\+\_\+x} & x-\/position of site. \\
\hline
{\em pos\+\_\+y} & y-\/position of site. \\
\hline
{\em pos\+\_\+z} & z-\/position of site. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
boolean answer. 
\end{DoxyReturn}
\index{Grid\+Utils@{Grid\+Utils}!is\+On\+Sender\+Layer@{is\+On\+Sender\+Layer}}
\index{is\+On\+Sender\+Layer@{is\+On\+Sender\+Layer}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{is\+On\+Sender\+Layer(double site\+\_\+position, e\+Cartesian\+Direction dir, e\+Min\+Max minmax)}{isOnSenderLayer(double site_position, eCartesianDirection dir, eMinMax minmax)}}]{\setlength{\rightskip}{0pt plus 5cm}bool Grid\+Utils\+::is\+On\+Sender\+Layer (
\begin{DoxyParamCaption}
\item[{double}]{site\+\_\+position, }
\item[{{\bf e\+Cartesian\+Direction}}]{dir, }
\item[{{\bf e\+Min\+Max}}]{minmax}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_grid_utils_a595b78d268cdbc0e6a3b008ac93e0cb4}{}\label{class_grid_utils_a595b78d268cdbc0e6a3b008ac93e0cb4}


Check whether site is on an inner (sender) halo. 

Wrapper available which checks every halo. This method only checks the halo specified by the Cartesian direction and whether it is the left/bottom/front (minimum) or right/top/back (maximum) edge of the block.


\begin{DoxyParams}{Parameters}
{\em site\+\_\+position} & position of site. \\
\hline
{\em dir} & cartesian direction. \\
\hline
{\em minmax} & choice of edge in given direction. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
boolean answer. 
\end{DoxyReturn}
\index{Grid\+Utils@{Grid\+Utils}!is\+On\+This\+Rank@{is\+On\+This\+Rank}}
\index{is\+On\+This\+Rank@{is\+On\+This\+Rank}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{is\+On\+This\+Rank(double x, double y, double z, e\+Location\+On\+Rank loc=e\+None, const Grid\+Obj $\ast$grid=nullptr, std\+::vector$<$ int $>$ $\ast$pos=nullptr)}{isOnThisRank(double x, double y, double z, eLocationOnRank loc=eNone, const GridObj *grid=nullptr, std::vector< int > *pos=nullptr)}}]{\setlength{\rightskip}{0pt plus 5cm}bool Grid\+Utils\+::is\+On\+This\+Rank (
\begin{DoxyParamCaption}
\item[{double}]{x, }
\item[{double}]{y, }
\item[{double}]{z, }
\item[{{\bf e\+Location\+On\+Rank}}]{loc = {\ttfamily {\bf e\+None}}, }
\item[{const {\bf Grid\+Obj} $\ast$}]{grid = {\ttfamily nullptr}, }
\item[{std\+::vector$<$ int $>$ $\ast$}]{pos = {\ttfamily nullptr}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_grid_utils_adcf9512bd143ac0b9ef7eec33f1510ec}{}\label{class_grid_utils_adcf9512bd143ac0b9ef7eec33f1510ec}


Finds out whether site with supplied position is on the current rank. 

Will return true if the site is in the halo as well (send or recv). Location information provided to indicate where point is. Returns e\+None enumeration if not request or if query is false. If a grid is supplied, will only return true if site is on the grid supplied. If you want to exclude the sites that belong to the halo you can call \hyperlink{class_grid_utils_abfec29d90b6942de2f3c52c225a4d888}{is\+On\+Recv\+Layer()} or \hyperlink{class_grid_utils_af0692236725709af2d98872805fc84ae}{is\+On\+Sender\+Layer()} on the same site.


\begin{DoxyParams}[1]{Parameters}
 & {\em x} & x-\/position of site. \\
\hline
 & {\em y} & y-\/position of site. \\
\hline
 & {\em z} & z-\/position of site. \\
\hline
\mbox{\tt out}  & {\em pos} & pointer to the start of a vector in which local indices are returned. \\
\hline
 & {\em grid} & grid being queried. \\
\hline
\mbox{\tt out}  & {\em loc} & description of the location of the point. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
boolean answer. 
\end{DoxyReturn}
\index{Grid\+Utils@{Grid\+Utils}!is\+On\+This\+Rank@{is\+On\+This\+Rank}}
\index{is\+On\+This\+Rank@{is\+On\+This\+Rank}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{is\+On\+This\+Rank(double xyz, e\+Cartesian\+Direction dir, e\+Location\+On\+Rank loc=e\+None, const Grid\+Obj $\ast$grid=nullptr, int $\ast$pos=nullptr)}{isOnThisRank(double xyz, eCartesianDirection dir, eLocationOnRank loc=eNone, const GridObj *grid=nullptr, int *pos=nullptr)}}]{\setlength{\rightskip}{0pt plus 5cm}bool Grid\+Utils\+::is\+On\+This\+Rank (
\begin{DoxyParamCaption}
\item[{double}]{xyz, }
\item[{{\bf e\+Cartesian\+Direction}}]{dir, }
\item[{{\bf e\+Location\+On\+Rank}}]{loc = {\ttfamily {\bf e\+None}}, }
\item[{const {\bf Grid\+Obj} $\ast$}]{grid = {\ttfamily nullptr}, }
\item[{int $\ast$}]{pos = {\ttfamily nullptr}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_grid_utils_a4eca1ee0dff756b5cd65d45f84b24118}{}\label{class_grid_utils_a4eca1ee0dff756b5cd65d45f84b24118}


Finds out whether the supplied position can be found on the current rank. 

Direction-\/specific version of the overload.


\begin{DoxyParams}[1]{Parameters}
 & {\em xyz} & position (x, y or z) \\
\hline
 & {\em dir} & cartesian direction of interest (x, y or z). \\
\hline
\mbox{\tt out}  & {\em loc} & description of the location of the point. \\
\hline
 & {\em grid} & grid being queried. \\
\hline
\mbox{\tt out}  & {\em pos} & the local index of the found site. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
boolean answer. 
\end{DoxyReturn}
\index{Grid\+Utils@{Grid\+Utils}!is\+On\+Transition\+Layer@{is\+On\+Transition\+Layer}}
\index{is\+On\+Transition\+Layer@{is\+On\+Transition\+Layer}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{is\+On\+Transition\+Layer(double pos\+\_\+x, double pos\+\_\+y, double pos\+\_\+z, const Grid\+Obj $\ast$grid)}{isOnTransitionLayer(double pos_x, double pos_y, double pos_z, const GridObj *grid)}}]{\setlength{\rightskip}{0pt plus 5cm}bool Grid\+Utils\+::is\+On\+Transition\+Layer (
\begin{DoxyParamCaption}
\item[{double}]{pos\+\_\+x, }
\item[{double}]{pos\+\_\+y, }
\item[{double}]{pos\+\_\+z, }
\item[{const {\bf Grid\+Obj} $\ast$}]{grid}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_grid_utils_a78d9c31d1c15198d1455627d1fa29804}{}\label{class_grid_utils_a78d9c31d1c15198d1455627d1fa29804}


Check whether site is on a TL. 

Wrapper which checks every possible TL location on the grid supplied.


\begin{DoxyParams}{Parameters}
{\em pos\+\_\+x} & x-\/position of site. \\
\hline
{\em pos\+\_\+y} & y-\/position of site. \\
\hline
{\em pos\+\_\+z} & z-\/position of site. \\
\hline
{\em grid} & given grid on which to check. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
boolean answer. 
\end{DoxyReturn}
\index{Grid\+Utils@{Grid\+Utils}!is\+On\+Transition\+Layer@{is\+On\+Transition\+Layer}}
\index{is\+On\+Transition\+Layer@{is\+On\+Transition\+Layer}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{is\+On\+Transition\+Layer(double position, e\+Cartesian\+Direction dir, e\+Min\+Max minmax, const Grid\+Obj $\ast$grid)}{isOnTransitionLayer(double position, eCartesianDirection dir, eMinMax minmax, const GridObj *grid)}}]{\setlength{\rightskip}{0pt plus 5cm}bool Grid\+Utils\+::is\+On\+Transition\+Layer (
\begin{DoxyParamCaption}
\item[{double}]{position, }
\item[{{\bf e\+Cartesian\+Direction}}]{dir, }
\item[{{\bf e\+Min\+Max}}]{minmax, }
\item[{const {\bf Grid\+Obj} $\ast$}]{grid}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_grid_utils_af241bda5fffef58362b1e77d9d3de6dc}{}\label{class_grid_utils_af241bda5fffef58362b1e77d9d3de6dc}


Check whether site is on a specific TL (to upper). 

Wrapper available which checks every TL. This method only checks the TL specified by the Cartesian direction and whether it is the left/bottom/front (minimum) or right/top/back (maximum) edge of the supplied grid.


\begin{DoxyParams}{Parameters}
{\em position} & position of point. \\
\hline
{\em dir} & cartesian direction. \\
\hline
{\em minmax} & choice of edge in given direction. \\
\hline
{\em grid} & given grid on which to check. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
boolean answer. 
\end{DoxyReturn}
\index{Grid\+Utils@{Grid\+Utils}!is\+Overlap\+Periodic@{is\+Overlap\+Periodic}}
\index{is\+Overlap\+Periodic@{is\+Overlap\+Periodic}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{is\+Overlap\+Periodic(int i, int j, int k, const Grid\+Obj \&p\+Grid)}{isOverlapPeriodic(int i, int j, int k, const GridObj &pGrid)}}]{\setlength{\rightskip}{0pt plus 5cm}bool Grid\+Utils\+::is\+Overlap\+Periodic (
\begin{DoxyParamCaption}
\item[{int}]{i, }
\item[{int}]{j, }
\item[{int}]{k, }
\item[{const {\bf Grid\+Obj} \&}]{g}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_grid_utils_a7c13884020ab181ee8cb6dd2ea7e4fd7}{}\label{class_grid_utils_a7c13884020ab181ee8cb6dd2ea7e4fd7}


Finds out whether halo containng i,j,k links to neighbour rank periodically. 

Checks the receiver layer containing local site i,j,k and determines from the M\+PI topology information whether this layer couples to an adjacent or periodic neighbour rank. I.\+e. if the neighbour is physically next to the rank or whether it is actaully at the other side of the domain.


\begin{DoxyParams}{Parameters}
{\em i} & local i-\/index of recv layer site being queried. \\
\hline
{\em j} & local j-\/index of recv layer site being queried. \\
\hline
{\em k} & local k-\/index of recv layer site being queried. \\
\hline
{\em g} & grid on which point being queried resides. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
boolean answer. 
\end{DoxyReturn}
\index{Grid\+Utils@{Grid\+Utils}!linspace@{linspace}}
\index{linspace@{linspace}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{linspace(double min, double max, int n)}{linspace(double min, double max, int n)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<$ double $>$ Grid\+Utils\+::linspace (
\begin{DoxyParamCaption}
\item[{double}]{min, }
\item[{double}]{max, }
\item[{int}]{n}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_grid_utils_a2f172a6dd8b2749ca1c8336a64a07e29}{}\label{class_grid_utils_a2f172a6dd8b2749ca1c8336a64a07e29}


Creates a linearly-\/spaced vector of values. 


\begin{DoxyParams}{Parameters}
{\em min} & starting value of output vector. \\
\hline
{\em max} & ending point of output vector. \\
\hline
{\em n} & number of values in output vector. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a vector with n uniformly spaced values between min and max. 
\end{DoxyReturn}
\index{Grid\+Utils@{Grid\+Utils}!matrix\+\_\+multiply@{matrix\+\_\+multiply}}
\index{matrix\+\_\+multiply@{matrix\+\_\+multiply}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{matrix\+\_\+multiply(const std\+::vector$<$ std\+::vector$<$ double $>$ $>$ \&\+A, const std\+::vector$<$ double $>$ \&x)}{matrix_multiply(const std::vector< std::vector< double > > &A, const std::vector< double > &x)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<$ double $>$ Grid\+Utils\+::matrix\+\_\+multiply (
\begin{DoxyParamCaption}
\item[{const std\+::vector$<$ std\+::vector$<$ double $>$ $>$ \&}]{A, }
\item[{const std\+::vector$<$ double $>$ \&}]{x}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_grid_utils_a0051918813c63802d79bd7d172e8ad8a}{}\label{class_grid_utils_a0051918813c63802d79bd7d172e8ad8a}


Multiplies matrix A by vector x. 


\begin{DoxyParams}{Parameters}
{\em A} & a matrix represented as a vector or vectors. \\
\hline
{\em x} & a vector. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a vector which is A $\ast$ x. 
\end{DoxyReturn}
\index{Grid\+Utils@{Grid\+Utils}!onespace@{onespace}}
\index{onespace@{onespace}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{onespace(int min, int max)}{onespace(int min, int max)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<$ int $>$ Grid\+Utils\+::onespace (
\begin{DoxyParamCaption}
\item[{int}]{min, }
\item[{int}]{max}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_grid_utils_a1f0d4a76be76a743c368c9a1d4d46cbc}{}\label{class_grid_utils_a1f0d4a76be76a743c368c9a1d4d46cbc}


Creates a linearly-\/spaced vector of integers. 


\begin{DoxyParams}{Parameters}
{\em min} & starting value of output vector. \\
\hline
{\em max} & ending point of output vector. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a vector with uniformly spaced integer values between min and max. 
\end{DoxyReturn}
\index{Grid\+Utils@{Grid\+Utils}!strided\+Copy@{strided\+Copy}}
\index{strided\+Copy@{strided\+Copy}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{strided\+Copy(\+Num\+Type $\ast$dest, Num\+Type $\ast$src, size\+\_\+t block, size\+\_\+t offset, size\+\_\+t stride, size\+\_\+t count, size\+\_\+t buf\+\_\+offset=0)}{stridedCopy(NumType *dest, NumType *src, size_t block, size_t offset, size_t stride, size_t count, size_t buf_offset=0)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Num\+Type $>$ static void Grid\+Utils\+::strided\+Copy (
\begin{DoxyParamCaption}
\item[{Num\+Type $\ast$}]{dest, }
\item[{Num\+Type $\ast$}]{src, }
\item[{size\+\_\+t}]{block, }
\item[{size\+\_\+t}]{offset, }
\item[{size\+\_\+t}]{stride, }
\item[{size\+\_\+t}]{count, }
\item[{size\+\_\+t}]{buf\+\_\+offset = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{class_grid_utils_aa3ca6e20ef4fa927cb845956d7565b1e}{}\label{class_grid_utils_aa3ca6e20ef4fa927cb845956d7565b1e}


Performs a strided memcpy. 

Memcpy() is designed to copy blocks of contiguous memory. Strided copy copies a pattern of contiguous blocks.


\begin{DoxyParams}{Parameters}
{\em dest} & pointer to start of destination memory. \\
\hline
{\em src} & pointer to start of source memory. \\
\hline
{\em block} & size of contiguous block. \\
\hline
{\em offset} & offset from the start of the soruce array. \\
\hline
{\em stride} & number of elements between start of first block and start of second. \\
\hline
{\em count} & number of blocks in pattern \\
\hline
{\em buf\+\_\+offset} & offset from start of destination buffer to start writing. Default is zero if not supplied. \\
\hline
\end{DoxyParams}
\index{Grid\+Utils@{Grid\+Utils}!subtract@{subtract}}
\index{subtract@{subtract}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{subtract(std\+::vector$<$ double $>$ a, std\+::vector$<$ double $>$ b)}{subtract(std::vector< double > a, std::vector< double > b)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<$ double $>$ Grid\+Utils\+::subtract (
\begin{DoxyParamCaption}
\item[{std\+::vector$<$ double $>$}]{a, }
\item[{std\+::vector$<$ double $>$}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_grid_utils_a6f5af65d6bb25e0d34be50670b41514f}{}\label{class_grid_utils_a6f5af65d6bb25e0d34be50670b41514f}


Subtracts two vectors. 


\begin{DoxyParams}{Parameters}
{\em a} & a vector. \\
\hline
{\em b} & a second vector. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a vector which is a -\/ b. 
\end{DoxyReturn}
\index{Grid\+Utils@{Grid\+Utils}!up\+To\+Zero@{up\+To\+Zero}}
\index{up\+To\+Zero@{up\+To\+Zero}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{up\+To\+Zero(\+Num\+Type x)}{upToZero(NumType x)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Num\+Type $>$ static Num\+Type Grid\+Utils\+::up\+To\+Zero (
\begin{DoxyParamCaption}
\item[{Num\+Type}]{x}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{class_grid_utils_a5a3e26a94e62833f0a9e5a4bda066dac}{}\label{class_grid_utils_a5a3e26a94e62833f0a9e5a4bda066dac}


Rounds a negative value up to zero. 

If value is positive, return the value unchanged.


\begin{DoxyParams}{Parameters}
{\em x} & value to be rounded \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Num\+Type rounded value 
\end{DoxyReturn}
\index{Grid\+Utils@{Grid\+Utils}!vecmultiply@{vecmultiply}}
\index{vecmultiply@{vecmultiply}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{vecmultiply(double scalar, std\+::vector$<$ double $>$ vec)}{vecmultiply(double scalar, std::vector< double > vec)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<$ double $>$ Grid\+Utils\+::vecmultiply (
\begin{DoxyParamCaption}
\item[{double}]{scalar, }
\item[{std\+::vector$<$ double $>$}]{vec}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_grid_utils_a01eba1d90d3414637d5031850ad89ce3}{}\label{class_grid_utils_a01eba1d90d3414637d5031850ad89ce3}


Multiplies a scalar by a vector. 


\begin{DoxyParams}{Parameters}
{\em scalar} & a scalar double. \\
\hline
{\em vec} & a vector double. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a vector which is a scalar multiplied by a vector. 
\end{DoxyReturn}
\index{Grid\+Utils@{Grid\+Utils}!vecnorm@{vecnorm}}
\index{vecnorm@{vecnorm}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{vecnorm(double vec[L\+\_\+\+D\+I\+MS])}{vecnorm(double vec[L_DIMS])}}]{\setlength{\rightskip}{0pt plus 5cm}double Grid\+Utils\+::vecnorm (
\begin{DoxyParamCaption}
\item[{double}]{vec\mbox{[}\+L\+\_\+\+D\+I\+M\+S\mbox{]}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_grid_utils_a1e0d0da69ec1543835b98bca884f8927}{}\label{class_grid_utils_a1e0d0da69ec1543835b98bca884f8927}


Computes the L2 norm using the vector supplied. 


\begin{DoxyParams}{Parameters}
{\em vec} & old-\/style C array representing a vector with the same number of number of components as the problem dimension. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the L2 norm. 
\end{DoxyReturn}
\index{Grid\+Utils@{Grid\+Utils}!vecnorm@{vecnorm}}
\index{vecnorm@{vecnorm}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{vecnorm(double val1, double val2)}{vecnorm(double val1, double val2)}}]{\setlength{\rightskip}{0pt plus 5cm}double Grid\+Utils\+::vecnorm (
\begin{DoxyParamCaption}
\item[{double}]{val1, }
\item[{double}]{val2}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_grid_utils_ae7d797edf50b3c3a448d59684a135aee}{}\label{class_grid_utils_ae7d797edf50b3c3a448d59684a135aee}


Computes the L2 norm using the vector components supplied. 


\begin{DoxyParams}{Parameters}
{\em val1} & first vector component. \\
\hline
{\em val2} & second vector component. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the L2 norm. 
\end{DoxyReturn}
\index{Grid\+Utils@{Grid\+Utils}!vecnorm@{vecnorm}}
\index{vecnorm@{vecnorm}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{vecnorm(double val1, double val2, double val3)}{vecnorm(double val1, double val2, double val3)}}]{\setlength{\rightskip}{0pt plus 5cm}double Grid\+Utils\+::vecnorm (
\begin{DoxyParamCaption}
\item[{double}]{val1, }
\item[{double}]{val2, }
\item[{double}]{val3}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_grid_utils_a6caced99b15b01746c1fb5828c447034}{}\label{class_grid_utils_a6caced99b15b01746c1fb5828c447034}


Computes the L2 norm using the vector components supplied. 


\begin{DoxyParams}{Parameters}
{\em val1} & first vector component. \\
\hline
{\em val2} & second vector component. \\
\hline
{\em val3} & third vector component. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the L2 norm. 
\end{DoxyReturn}
\index{Grid\+Utils@{Grid\+Utils}!vecnorm@{vecnorm}}
\index{vecnorm@{vecnorm}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{vecnorm(std\+::vector$<$ double $>$ vec)}{vecnorm(std::vector< double > vec)}}]{\setlength{\rightskip}{0pt plus 5cm}double Grid\+Utils\+::vecnorm (
\begin{DoxyParamCaption}
\item[{std\+::vector$<$ double $>$}]{vec}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_grid_utils_a45167f9bde2e34d868a4ccc64f588ab2}{}\label{class_grid_utils_a45167f9bde2e34d868a4ccc64f588ab2}


Computes the L2 norm using the vector supplied. 


\begin{DoxyParams}{Parameters}
{\em vec} & C++ std\+::vector. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the L2 norm. 
\end{DoxyReturn}
\index{Grid\+Utils@{Grid\+Utils}!vecnorm@{vecnorm}}
\index{vecnorm@{vecnorm}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{vecnorm(\+Num\+Type a1, Num\+Type a2, Num\+Type a3)}{vecnorm(NumType a1, NumType a2, NumType a3)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Num\+Type $>$ static Num\+Type Grid\+Utils\+::vecnorm (
\begin{DoxyParamCaption}
\item[{Num\+Type}]{a1, }
\item[{Num\+Type}]{a2, }
\item[{Num\+Type}]{a3}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{class_grid_utils_a78aa4876d7066bce253c52457e7b901d}{}\label{class_grid_utils_a78aa4876d7066bce253c52457e7b901d}


Computes the L2-\/norm. 


\begin{DoxyParams}{Parameters}
{\em a1} & first component of the vector \\
\hline
{\em a2} & second component of the vector \\
\hline
{\em a3} & third component of the vector \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Num\+Type scalar quantity 
\end{DoxyReturn}
\index{Grid\+Utils@{Grid\+Utils}!vecnorm@{vecnorm}}
\index{vecnorm@{vecnorm}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{vecnorm(\+Num\+Type a1, Num\+Type a2)}{vecnorm(NumType a1, NumType a2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Num\+Type $>$ static Num\+Type Grid\+Utils\+::vecnorm (
\begin{DoxyParamCaption}
\item[{Num\+Type}]{a1, }
\item[{Num\+Type}]{a2}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{class_grid_utils_a7a169fc043a585f20936b314def45fe7}{}\label{class_grid_utils_a7a169fc043a585f20936b314def45fe7}


Computes the L2-\/norm. 


\begin{DoxyParams}{Parameters}
{\em a1} & first component of the vector \\
\hline
{\em a2} & second component of the vector \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Num\+Type scalar quantity 
\end{DoxyReturn}


\subsection{Member Data Documentation}
\index{Grid\+Utils@{Grid\+Utils}!dir\+\_\+reflect@{dir\+\_\+reflect}}
\index{dir\+\_\+reflect@{dir\+\_\+reflect}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{dir\+\_\+reflect}{dir_reflect}}]{\setlength{\rightskip}{0pt plus 5cm}const int Grid\+Utils\+::dir\+\_\+reflect\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_grid_utils_ae2b566735d973bc25f1a6416010efa70}{}\label{class_grid_utils_ae2b566735d973bc25f1a6416010efa70}
{\bfseries Initial value\+:}
\begin{DoxyCode}
= 
    \{
        \{1, 0, 2, 3, 7, 6, 5, 4, 8\}, 
        \{1, 0, 2, 3, 4, 6, 5, 4, 8\},
        \{0, 1, 3, 2, 6, 7, 4, 5, 8\},
        \{0, 1, 3, 2, 6, 7, 4, 5, 8\}
    \}
\end{DoxyCode}


Array with hardcoded direction numbering for specular reflection. 

\index{Grid\+Utils@{Grid\+Utils}!logfile@{logfile}}
\index{logfile@{logfile}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{logfile}{logfile}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ofstream $\ast$ Grid\+Utils\+::logfile\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_grid_utils_a298239096e929c1ba4eba925e351c1b3}{}\label{class_grid_utils_a298239096e929c1ba4eba925e351c1b3}


Handle to output file. 

\index{Grid\+Utils@{Grid\+Utils}!path\+\_\+str@{path\+\_\+str}}
\index{path\+\_\+str@{path\+\_\+str}!Grid\+Utils@{Grid\+Utils}}
\subsubsection[{\texorpdfstring{path\+\_\+str}{path_str}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string Grid\+Utils\+::path\+\_\+str\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_grid_utils_a9b58748e9e05e84852962d7abc7942e3}{}\label{class_grid_utils_a9b58748e9e05e84852962d7abc7942e3}


Static string representing output path. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
\hyperlink{_grid_utils_8h}{Grid\+Utils.\+h}\item 
\hyperlink{_grid_obj_8cpp}{Grid\+Obj.\+cpp}\item 
\hyperlink{_grid_utils_8cpp}{Grid\+Utils.\+cpp}\item 
\hyperlink{main__lbm_8cpp}{main\+\_\+lbm.\+cpp}\end{DoxyCompactItemize}
